!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],n):"object"==typeof exports?exports.ThreeDxfLoader=n(require("THREE")):t.ThreeDxfLoader=n(t.THREE)}("undefined"!=typeof self?self:this,(function(__WEBPACK_EXTERNAL_MODULE__0__){return function(t){var n={};function g(c){if(n[c])return n[c].exports;var I=n[c]={i:c,l:!1,exports:{}};return t[c].call(I.exports,I,I.exports,g),I.l=!0,I.exports}return g.m=t,g.c=n,g.d=function(t,n,c){g.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:c})},g.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},g.t=function(t,n){if(1&n&&(t=g(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var c=Object.create(null);if(g.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var I in t)g.d(c,I,function(n){return t[n]}.bind(null,I));return c},g.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return g.d(n,"a",n),n},g.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},g.p="",g(g.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci9leHRlcm5hbCBcIlRIUkVFXCI/ZmMwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn\'t print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don\'t have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \'trace\' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/NWM3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLG9DQUFPLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxQixLQUFLLE1BQU0sRUFJTjtBQUNMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"DXFLoader\", function() { return /* binding */ DXFLoader; });\n__webpack_require__.d(__webpack_exports__, \"Viewer\", function() { return /* binding */ Viewer; });\n\n// EXTERNAL MODULE: external \"THREE\"\nvar external_THREE_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/DxfArrayScanner.js\n/**\r\n * DxfArrayScanner\r\n *\r\n * Based off the AutoCad 2012 DXF Reference\r\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\r\n *\r\n * Reads through an array representing lines of a dxf file. Takes an array and\r\n * provides an easy interface to extract group code and value pairs.\r\n * @param data - an array where each element represents a line in the dxf file\r\n * @constructor\r\n */\r\nfunction DxfArrayScanner(data) {\r\n\tthis._pointer = 0;\r\n\tthis._data = data;\r\n\tthis._eof = false;\r\n}\r\n\r\n/**\r\n * Gets the next group (code, value) from the array. A group is two consecutive elements\r\n * in the array. The first is the code, the second is the value.\r\n * @returns {{code: Number}|*}\r\n */\r\nDxfArrayScanner.prototype.next = function() {\r\n\tvar group;\r\n\tif(!this.hasNext()) {\r\n\t\tif(!this._eof)\r\n\t\t\tthrow new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\r\n\t\telse\r\n\t\t\tthrow new Error('Cannot call \\'next\\' after EOF group has been read');\r\n\t}\r\n\r\n\tgroup = {\r\n\t\tcode: parseInt(this._data[this._pointer])\r\n\t};\r\n\r\n\tthis._pointer++;\r\n\r\n\tgroup.value = parseGroupValue(group.code, this._data[this._pointer].trim());\r\n\t\r\n\tthis._pointer++;\r\n\r\n\tif(group.code === 0 && group.value === 'EOF') this._eof = true;\r\n\r\n\tthis.lastReadGroup = group;\r\n\r\n\treturn group;\r\n};\r\n\r\nDxfArrayScanner.prototype.peek = function() {\r\n\tif(!this.hasNext()) {\r\n\t\tif(!this._eof)\r\n\t\t\tthrow new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\r\n\t\telse\r\n\t\t\tthrow new Error('Cannot call \\'next\\' after EOF group has been read');\r\n\t}\r\n\t\r\n\tvar group = {\r\n\t\tcode: parseInt(this._data[this._pointer])\r\n\t};\r\n\r\n\tgroup.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\r\n\r\n\treturn group;\r\n};\r\n\r\n\r\nDxfArrayScanner.prototype.rewind = function(numberOfGroups) {\r\n\tnumberOfGroups = numberOfGroups || 1;\r\n\tthis._pointer = this._pointer - numberOfGroups * 2;\r\n};\r\n\r\n/**\r\n * Returns true if there is another code/value pair (2 elements in the array).\r\n * @returns {boolean}\r\n */\r\nDxfArrayScanner.prototype.hasNext = function() {\r\n\t// Check if we have read EOF group code\r\n\tif(this._eof) {\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// We need to be sure there are two lines available\r\n\tif(this._pointer > this._data.length - 2) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * Returns true if the scanner is at the end of the array\r\n * @returns {boolean}\r\n */\r\nDxfArrayScanner.prototype.isEOF = function() {\r\n\treturn this._eof;\r\n};\r\n\r\n/**\r\n * Parse a value to its proper type.\r\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\r\n *\r\n * @param code\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction parseGroupValue(code, value) {\r\n\tif(code <= 9) return value;\r\n\tif(code >= 10 && code <= 59) return parseFloat(value);\r\n\tif(code >= 60 && code <= 99) return parseInt(value);\r\n\tif(code >= 100 && code <= 109) return value;\r\n\tif(code >= 110 && code <= 149) return parseFloat(value);\r\n\tif(code >= 160 && code <= 179) return parseInt(value);\r\n\tif(code >= 210 && code <= 239) return parseFloat(value);\r\n\tif(code >= 270 && code <= 289) return parseInt(value);\r\n\tif(code >= 290 && code <= 299) return parseBoolean(value);\r\n\tif(code >= 300 && code <= 369) return value;\r\n\tif(code >= 370 && code <= 389) return parseInt(value);\r\n\tif(code >= 390 && code <= 399) return value;\r\n\tif(code >= 400 && code <= 409) return parseInt(value);\r\n\tif(code >= 410 && code <= 419) return value;\r\n\tif(code >= 420 && code <= 429) return parseInt(value);\r\n\tif(code >= 430 && code <= 439) return value;\r\n\tif(code >= 440 && code <= 459) return parseInt(value);\r\n\tif(code >= 460 && code <= 469) return parseFloat(value);\r\n\tif(code >= 470 && code <= 481) return value;\r\n\tif(code === 999) return value;\r\n\tif(code >= 1000 && code <= 1009) return value;\r\n\tif(code >= 1010 && code <= 1059) return parseFloat(value);\r\n\tif(code >= 1060 && code <= 1071) return parseInt(value);\r\n\r\n\tconsole.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Parse a boolean according to a 1 or 0 value\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nfunction parseBoolean(str) {\r\n\tif(str === '0') return false;\r\n\tif(str === '1') return true;\r\n\tthrow TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\r\n}\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/AutoCadColorIndex.js\n/**\r\n * AutoCad files sometimes use an indexed color value between 1 and 255 inclusive.\r\n * Each value corresponds to a color. index 1 is red, that is 16711680 or 0xFF0000.\r\n * index 0 and 256, while included in this array, are actually reserved for inheritance\r\n * values in AutoCad so they should not be used for index color lookups.\r\n */\r\n\r\n/* harmony default export */ var AutoCadColorIndex = ([\r\n 0,\r\n 16711680,\r\n 16776960,\r\n 65280,\r\n 65535,\r\n 255,\r\n 16711935,\r\n 16777215,\r\n 8421504,\r\n 12632256,\r\n 16711680,\r\n 16744319,\r\n 13369344,\r\n 13395558,\r\n 10027008,\r\n 10046540,\r\n 8323072,\r\n 8339263,\r\n 4980736,\r\n 4990502,\r\n 16727808,\r\n 16752511,\r\n 13382400,\r\n 13401958,\r\n 10036736,\r\n 10051404,\r\n 8331008,\r\n 8343359,\r\n 4985600,\r\n 4992806,\r\n 16744192,\r\n 16760703,\r\n 13395456,\r\n 13408614,\r\n 10046464,\r\n 10056268,\r\n 8339200,\r\n 8347455,\r\n 4990464,\r\n 4995366,\r\n 16760576,\r\n 16768895,\r\n 13408512,\r\n 13415014,\r\n 10056192,\r\n 10061132,\r\n 8347392,\r\n 8351551,\r\n 4995328,\r\n 4997670,\r\n 16776960,\r\n 16777087,\r\n 13421568,\r\n 13421670,\r\n 10000384,\r\n 10000460,\r\n 8355584,\r\n 8355647,\r\n 5000192,\r\n 5000230,\r\n 12582656,\r\n 14679935,\r\n 10079232,\r\n 11717734,\r\n 7510016,\r\n 8755276,\r\n 6258432,\r\n 7307071,\r\n 3755008,\r\n 4344870,\r\n 8388352,\r\n 12582783,\r\n 6736896,\r\n 10079334,\r\n 5019648,\r\n 7510092,\r\n 4161280,\r\n 6258495,\r\n 2509824,\r\n 3755046,\r\n 4194048,\r\n 10485631,\r\n 3394560,\r\n 8375398,\r\n 2529280,\r\n 6264908,\r\n 2064128,\r\n 5209919,\r\n 1264640,\r\n 3099686,\r\n 65280,\r\n 8388479,\r\n 52224,\r\n 6736998,\r\n 38912,\r\n 5019724,\r\n 32512,\r\n 4161343,\r\n 19456,\r\n 2509862,\r\n 65343,\r\n 8388511,\r\n 52275,\r\n 6737023,\r\n 38950,\r\n 5019743,\r\n 32543,\r\n 4161359,\r\n 19475,\r\n 2509871,\r\n 65407,\r\n 8388543,\r\n 52326,\r\n 6737049,\r\n 38988,\r\n 5019762,\r\n 32575,\r\n 4161375,\r\n 19494,\r\n 2509881,\r\n 65471,\r\n 8388575,\r\n 52377,\r\n 6737074,\r\n 39026,\r\n 5019781,\r\n 32607,\r\n 4161391,\r\n 19513,\r\n 2509890,\r\n 65535,\r\n 8388607,\r\n 52428,\r\n 6737100,\r\n 39064,\r\n 5019800,\r\n 32639,\r\n 4161407,\r\n 19532,\r\n 2509900,\r\n 49151,\r\n 8380415,\r\n 39372,\r\n 6730444,\r\n 29336,\r\n 5014936,\r\n 24447,\r\n 4157311,\r\n 14668,\r\n 2507340,\r\n 32767,\r\n 8372223,\r\n 26316,\r\n 6724044,\r\n 19608,\r\n 5010072,\r\n 16255,\r\n 4153215,\r\n 9804,\r\n 2505036,\r\n 16383,\r\n 8364031,\r\n 13260,\r\n 6717388,\r\n 9880,\r\n 5005208,\r\n 8063,\r\n 4149119,\r\n 4940,\r\n 2502476,\r\n 255,\r\n 8355839,\r\n 204,\r\n 6710988,\r\n 152,\r\n 5000344,\r\n 127,\r\n 4145023,\r\n 76,\r\n 2500172,\r\n 4129023,\r\n 10452991,\r\n 3342540,\r\n 8349388,\r\n 2490520,\r\n 6245528,\r\n 2031743,\r\n 5193599,\r\n 1245260,\r\n 3089996,\r\n 8323327,\r\n 12550143,\r\n 6684876,\r\n 10053324,\r\n 4980888,\r\n 7490712,\r\n 4128895,\r\n 6242175,\r\n 2490444,\r\n 3745356,\r\n 12517631,\r\n 14647295,\r\n 10027212,\r\n 11691724,\r\n 7471256,\r\n 8735896,\r\n 6226047,\r\n 7290751,\r\n 3735628,\r\n 4335180,\r\n 16711935,\r\n 16744447,\r\n 13369548,\r\n 13395660,\r\n 9961624,\r\n 9981080,\r\n 8323199,\r\n 8339327,\r\n 4980812,\r\n 4990540,\r\n 16711871,\r\n 16744415,\r\n 13369497,\r\n 13395634,\r\n 9961586,\r\n 9981061,\r\n 8323167,\r\n 8339311,\r\n 4980793,\r\n 4990530,\r\n 16711807,\r\n 16744383,\r\n 13369446,\r\n 13395609,\r\n 9961548,\r\n 9981042,\r\n 8323135,\r\n 8339295,\r\n 4980774,\r\n 4990521,\r\n 16711743,\r\n 16744351,\r\n 13369395,\r\n 13395583,\r\n 9961510,\r\n 9981023,\r\n 8323103,\r\n 8339279,\r\n 4980755,\r\n 4990511,\r\n 3355443,\r\n 5987163,\r\n 8684676,\r\n 11382189,\r\n 14079702,\r\n 16777215\r\n]);\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/ParseHelpers.js\n\r\n\r\n/**\r\n * Returns the truecolor value of the given AutoCad color index value\r\n * @return {Number} truecolor value as a number\r\n */\r\nfunction getAcadColor(index) {\r\n\treturn AutoCadColorIndex[index];\r\n}\r\n\r\n/**\r\n * Parses the 2D or 3D coordinate, vector, or point. When complete,\r\n * the scanner remains on the last group of the coordinate.\r\n * @param {*} scanner \r\n */\r\nfunction ParseHelpers_parsePoint(scanner) {\r\n    var point = {};\r\n\r\n    // Reread group for the first coordinate\r\n    scanner.rewind();\r\n    var curr = scanner.next();\r\n\r\n    var code = curr.code;\r\n    point.x = curr.value;\r\n\r\n    code += 10;\r\n    curr = scanner.next();\r\n    if(curr.code != code)\r\n        throw new Error('Expected code for point value to be ' + code +\r\n        ' but got ' + curr.code + '.');\r\n    point.y = curr.value;\r\n\r\n    code += 10;\r\n    curr = scanner.next();\r\n    if(curr.code != code)\r\n    {\r\n        // Only the x and y are specified. Don't read z.\r\n        scanner.rewind(); // Let the calling code advance off the point\r\n        return point;\r\n    }\r\n    point.z = curr.value;\r\n    \r\n    return point;\r\n};\r\n\r\n/**\r\n * Attempts to parse codes common to all entities. Returns true if the group\r\n * was handled by this function.\r\n * @param {*} entity - the entity currently being parsed \r\n * @param {*} curr - the current group being parsed\r\n */\r\nfunction checkCommonEntityProperties(entity, curr) {\r\n    switch(curr.code) {\r\n        case 0:\r\n            entity.type = curr.value;\r\n            break;\r\n        case 5:\r\n            entity.handle = curr.value;\r\n            break;\r\n        case 6:\r\n            entity.lineType = curr.value;\r\n            break;\r\n        case 8: // Layer name\r\n            entity.layer = curr.value;\r\n            break;\r\n        case 48:\r\n            entity.lineTypeScale = curr.value;\r\n            break;\r\n        case 60:\r\n            entity.visible = curr.value === 0;\r\n            break;\r\n        case 62: // Acad Index Color. 0 inherits ByBlock. 256 inherits ByLayer. Default is bylayer\r\n            entity.colorIndex = curr.value;\r\n            entity.color = getAcadColor(Math.abs(curr.value));\r\n            break;\r\n        case 67:\r\n            entity.inPaperSpace = curr.value !== 0;\r\n            break;\r\n        case 100:\r\n            //ignore\r\n            break;\r\n        case 330:\r\n            entity.ownerHandle = curr.value;\r\n            break;\r\n        case 347:\r\n            entity.materialObjectHandle = curr.value;\r\n            break;\r\n        case 370:\r\n            //From https://www.woutware.com/Forum/Topic/955/lineweight?returnUrl=%2FForum%2FUserPosts%3FuserId%3D478262319\r\n            // An integer representing 100th of mm, must be one of the following values:\r\n            // 0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.\r\n            // -3 = STANDARD, -2 = BYLAYER, -1 = BYBLOCK\r\n            entity.lineweight = curr.value;\r\n            break;\r\n        case 420: // TrueColor Color\r\n            entity.color = curr.value;\r\n            break;\r\n        case 1000: \r\n            entity.extendedData = entity.extendedData || {};\r\n            entity.extendedData.customStrings = entity.extendedData.customStrings || []; \r\n            entity.extendedData.customStrings.push(curr.value);\r\n            break;\r\n        case 1001: \r\n            entity.extendedData = entity.extendedData || {};\r\n            entity.extendedData.applicationName = curr.value;\r\n            break;\r\n        default:\r\n            return false;\r\n    }\r\n    return true;\r\n};\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/3dface.js\n\r\n\r\n\r\nfunction EntityParser() {}\r\n\r\nEntityParser.ForEntityName = '3DFACE';\r\n\r\nEntityParser.prototype.parseEntity = function(scanner, curr) {\r\n\r\n    var entity = { type: curr.value, vertices: [] };\r\n    curr = scanner.next();\r\n    while (curr !== 'EOF') {\r\n        if (curr.code === 0) break;\r\n        switch (curr.code) {\r\n            case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\r\n                entity.shape = ((curr.value & 1) === 1);\r\n                entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\r\n                break;\r\n            case 10: // X coordinate of point\r\n                entity.vertices = parse3dFaceVertices(scanner, curr);\r\n                curr = scanner.lastReadGroup;\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\r\n\r\nfunction parse3dFaceVertices(scanner, curr) {\r\n    var vertices = [],\r\n        i;\r\n    var vertexIsStarted = false;\r\n    var vertexIsFinished = false;\r\n    var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\r\n    \r\n    for (i = 0; i <= verticesPer3dFace; i++) {\r\n        var vertex = {};\r\n        while (curr !== 'EOF') {\r\n            if (curr.code === 0 || vertexIsFinished) break;\r\n\r\n            switch (curr.code) {\r\n                case 10: // X0\r\n                case 11: // X1\r\n                case 12: // X2\r\n                case 13: // X3\r\n                    if (vertexIsStarted) {\r\n                        vertexIsFinished = true;\r\n                        continue;\r\n                    }\r\n                    vertex.x = curr.value;\r\n                    vertexIsStarted = true;\r\n                    break;\r\n                case 20: // Y\r\n                case 21:\r\n                case 22:\r\n                case 23:\r\n                    vertex.y = curr.value;\r\n                    break;\r\n                case 30: // Z\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                    vertex.z = curr.value;\r\n                    break;\r\n                default:\r\n                    // it is possible to have entity codes after the vertices.  \r\n                    // So if code is not accounted for return to entity parser where it might be accounted for\r\n                    return vertices;\r\n                    continue;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\r\n        vertices.push(vertex);\r\n        vertexIsStarted = false;\r\n        vertexIsFinished = false;\r\n    }\r\n    scanner.rewind();\r\n    return vertices;\r\n};\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/arc.js\n\r\n\r\n\r\nfunction arc_EntityParser() {}\r\n\r\narc_EntityParser.ForEntityName = 'ARC';\r\n\r\narc_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity, endAngle;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10: // X coordinate of point\r\n                entity.center = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40: // radius\r\n                entity.radius = curr.value;\r\n                break;\r\n            case 50: // start angle\r\n                entity.startAngle = Math.PI / 180 * curr.value;\r\n                break;\r\n            case 51: // end angle\r\n                entity.endAngle = Math.PI / 180 * curr.value;\r\n                entity.angleLength = entity.endAngle - entity.startAngle; // angleLength is deprecated\r\n                break;\r\n            default: // ignored attribute\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/attdef.js\n\r\n\r\n\r\nfunction attdef_EntityParser() {}\r\n\r\nattdef_EntityParser.ForEntityName = 'ATTDEF';\r\n\r\nattdef_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = {\r\n        type: curr.value,\r\n        scale: 1,\r\n        textStyle: 'STANDARD'\r\n     };\r\n    curr = scanner.next();\r\n    while (curr !== 'EOF') {\r\n        if (curr.code === 0) {\r\n            break;\r\n        }\r\n        switch(curr.code) {\r\n            case 1:\r\n                entity.text = curr.value;\r\n                break;\r\n            case 2:\r\n                entity.tag = curr.value;\r\n                break;\r\n            case 3:\r\n                entity.prompt = curr.value;\r\n                break;\r\n            case 7:\r\n                entity.textStyle = curr.value;\r\n                break;\r\n            case 10: // X coordinate of 'first alignment point'\r\n                entity.startPoint = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 11: // X coordinate of 'second alignment point'\r\n                entity.endPoint = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 39:\r\n                entity.thickness = curr.value;\r\n                break;\r\n            case 40:\r\n                entity.textHeight = curr.value;\r\n                break;\r\n            case 41:\r\n                entity.scale = curr.value;\r\n                break;\r\n            case 50:\r\n                entity.rotation = curr.value;\r\n                break;\r\n            case 51:\r\n                entity.obliqueAngle = curr.value;\r\n                break;\r\n            case 70:\r\n                entity.invisible = !!(curr.value & 0x01);\r\n                entity.constant = !!(curr.value & 0x02);\r\n                entity.verificationRequired = !!(curr.value & 0x04);\r\n                entity.preset = !!(curr.value & 0x08);\r\n                break;\r\n            case 71:\r\n                entity.backwards = !!(curr.value & 0x02);\r\n                entity.mirrored = !!(curr.value & 0x04);\r\n                break;\r\n            case 72:\r\n                // TODO: enum values?\r\n                entity.horizontalJustification = curr.value;\r\n                break;\r\n            case 73:\r\n                entity.fieldLength = curr.value;\r\n                break;\r\n            case 74:\r\n                // TODO: enum values?\r\n                entity.verticalJustification = curr.value;\r\n                break;\r\n            case 100:\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirectionX = curr.value;\r\n                break;\r\n            case 220:\r\n                entity.extrusionDirectionY = curr.value;\r\n                break;\r\n            case 230:\r\n                entity.extrusionDirectionZ = curr.value;\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/circle.js\n\r\n\r\n\r\nfunction circle_EntityParser() {}\r\n\r\ncircle_EntityParser.ForEntityName = 'CIRCLE';\r\n\r\ncircle_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity, endAngle;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10: // X coordinate of point\r\n                entity.center = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40: // radius\r\n                entity.radius = curr.value;\r\n                break;\r\n            case 50: // start angle\r\n                entity.startAngle = Math.PI / 180 * curr.value;\r\n                break;\r\n            case 51: // end angle\r\n                endAngle = Math.PI / 180 * curr.value;\r\n                if(endAngle < entity.startAngle)\r\n                    entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;\r\n                else\r\n                    entity.angleLength = endAngle - entity.startAngle;\r\n                entity.endAngle = endAngle;\r\n                break;\r\n            default: // ignored attribute\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/dimension.js\n\r\n\r\n\r\nfunction dimension_EntityParser() {}\r\n\r\ndimension_EntityParser.ForEntityName = 'DIMENSION';\r\n\r\ndimension_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n\t\tentity = { type: curr.value };\r\n\t\tcurr = scanner.next();\r\n\t\twhile(curr !== 'EOF') {\r\n\t\t\tif(curr.code === 0) break;\r\n\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 2: // Referenced block name\r\n\t\t\t\t\tentity.block = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 10: // X coordinate of 'first alignment point'\r\n\t\t\t\t\tentity.anchorPoint = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 11:\r\n\t\t\t\t\tentity.middleOfText = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 12: // Insertion point for clones of a dimension\r\n\t\t\t\t\tentity.insertionPoint = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 13: // Definition point for linear and angular dimensions \r\n\t\t\t\t\tentity.linearOrAngularPoint1 = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 14: // Definition point for linear and angular dimensions \r\n\t\t\t\t\tentity.linearOrAngularPoint2 = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 15: // Definition point for diameter, radius, and angular dimensions\r\n\t\t\t\t\tentity.diameterOrRadiusPoint = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 16: // Point defining dimension arc for angular dimensions\r\n\t\t\t\t\tentity.arcPoint = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 70: // Dimension type\r\n\t\t\t\t\tentity.dimensionType = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 71: // 5 = Middle center\r\n\t\t\t\t\tentity.attachmentPoint = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 42: // Actual measurement\r\n\t\t\t\t\tentity.actualMeasurement = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 1: // Text entered by user explicitly\r\n\t\t\t\t\tentity.text = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 50: // Angle of rotated, horizontal, or vertical dimensions\r\n\t\t\t\t\tentity.angle = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault: // check common entity attributes\r\n\t\t\t\t\tcheckCommonEntityProperties(entity, curr);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcurr = scanner.next();\r\n\t\t}\r\n\r\n\t\treturn entity;\r\n};\r\n\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/ellipse.js\n\r\n\r\n\r\nfunction ellipse_EntityParser() {}\r\n\r\nellipse_EntityParser.ForEntityName = 'ELLIPSE';\r\n\r\nellipse_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10:\r\n                entity.center = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 11:\r\n                entity.majorAxisEndPoint = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40:\r\n                entity.axisRatio = curr.value;\r\n                break;\r\n            case 41:\r\n                entity.startAngle = curr.value;\r\n                break;\r\n            case 42:\r\n                entity.endAngle = curr.value;\r\n                break;\r\n            case 2:\r\n                entity.name = curr.value;\r\n                break;\r\n            default: // check common entity attributes\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        \r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/insert.js\n\r\n\r\n\r\nfunction insert_EntityParser() {}\r\n\r\ninsert_EntityParser.ForEntityName = 'INSERT';\r\n\r\ninsert_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 2:\r\n                entity.name = curr.value;\r\n                break;\r\n            case 41:\r\n                entity.xScale = curr.value;\r\n                break;\r\n            case 42:\r\n                entity.yScale = curr.value;\r\n                break;\r\n            case 43:\r\n                entity.zScale = curr.value;\r\n                break;\r\n            case 10:\r\n                entity.position = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 50:\r\n                entity.rotation = curr.value;\r\n                break;\r\n            case 70:\r\n                entity.columnCount = curr.value;\r\n                break;\r\n            case 71:\r\n                entity.rowCount = curr.value;\r\n                break;\r\n            case 44:\r\n                entity.columnSpacing = curr.value;\r\n                break;\r\n            case 45:\r\n                entity.rowSpacing = curr.value;\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirection = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            default: // check common entity attributes\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\r\n\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/line.js\n\r\n\r\n\r\nfunction line_EntityParser() {}\r\n\r\nline_EntityParser.ForEntityName = 'LINE';\r\n\r\nline_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = { type: curr.value, vertices: [] };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10: // X coordinate of point\r\n                entity.vertices.unshift(ParseHelpers_parsePoint(scanner));\r\n                break;\r\n            case 11:\r\n                entity.vertices.push(ParseHelpers_parsePoint(scanner));\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirection = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 100:\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        \r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/lwpolyline.js\n\r\n\r\n\r\nfunction lwpolyline_EntityParser() {}\r\n\r\nlwpolyline_EntityParser.ForEntityName = 'LWPOLYLINE';\r\n\r\nlwpolyline_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = { type: curr.value, vertices: [] },\r\n        numberOfVertices = 0;\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 38:\r\n                entity.elevation = curr.value;\r\n                break;\r\n            case 39:\r\n                entity.depth = curr.value;\r\n                break;\r\n            case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\r\n                entity.shape = ((curr.value & 1) === 1);\r\n                entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\r\n                break;\r\n            case 90:\r\n                numberOfVertices = curr.value;\r\n                break;\r\n            case 10: // X coordinate of point\r\n                entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\r\n                break;\r\n            case 43:\r\n                if(curr.value !== 0) entity.width = curr.value;\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirectionX = curr.value;\r\n                break;\r\n            case 220:\r\n                entity.extrusionDirectionY = curr.value;\r\n                break;\r\n            case 230:\r\n                entity.extrusionDirectionZ = curr.value;\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\r\n\r\nfunction parseLWPolylineVertices(n, scanner) {\r\n    if(!n || n <= 0) throw Error('n must be greater than 0 verticies');\r\n    var vertices = [], i;\r\n    var vertexIsStarted = false;\r\n    var vertexIsFinished = false;\r\n    var curr = scanner.lastReadGroup;\r\n\r\n    for(i = 0; i < n; i++) {\r\n        var vertex = {};\r\n        while(curr !== 'EOF') {\r\n            if(curr.code === 0 || vertexIsFinished) break;\r\n\r\n            switch(curr.code) {\r\n                case 10: // X\r\n                    if(vertexIsStarted) {\r\n                        vertexIsFinished = true;\r\n                        continue;\r\n                    }\r\n                    vertex.x = curr.value;\r\n                    vertexIsStarted = true;\r\n                    break;\r\n                case 20: // Y\r\n                    vertex.y = curr.value;\r\n                    break;\r\n                case 30: // Z\r\n                    vertex.z = curr.value;\r\n                    break;\r\n                case 40: // start width\r\n                    vertex.startWidth = curr.value;\r\n                    break;\r\n                case 41: // end width\r\n                    vertex.endWidth = curr.value;\r\n                    break;\r\n                case 42: // bulge\r\n                    if(curr.value != 0) vertex.bulge = curr.value;\r\n                    break;\r\n                default:\r\n                    // if we do not hit known code return vertices.  Code might belong to entity\r\n                    if (vertexIsStarted) {\r\n                        vertices.push(vertex);\r\n                    }\r\n                    scanner.rewind();\r\n                    return vertices;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\r\n        vertices.push(vertex);\r\n        vertexIsStarted = false;\r\n        vertexIsFinished = false;\r\n    }\r\n    scanner.rewind();\r\n    return vertices;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/mtext.js\n\r\n\r\n\r\nfunction mtext_EntityParser() {}\r\n\r\nmtext_EntityParser.ForEntityName = 'MTEXT';\r\n\r\nmtext_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = { type: curr.value };\r\n\t\tcurr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 3:\r\n                entity.text ? entity.text += curr.value : entity.text = curr.value;\r\n                break;\r\n            case 1:\r\n                entity.text ? entity.text += curr.value : entity.text = curr.value;\r\n                break;\r\n            case 10:\r\n                entity.position = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40:\r\n                //Note: this is the text height\r\n                entity.height = curr.value;\r\n                break;\r\n            case 41:\r\n                entity.width = curr.value;\r\n                break;\r\n            case 50:\r\n                entity.rotation = curr.value;\r\n                break;\r\n            case 71:\r\n                entity.attachmentPoint = curr.value;\r\n                break;\r\n            case 72:\r\n                entity.drawingDirection = curr.value;\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/point.js\n\r\n\r\n\r\nfunction point_EntityParser() {}\r\n\r\npoint_EntityParser.ForEntityName = 'POINT';\r\n\r\npoint_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10:\r\n                entity.position = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 39:\r\n                entity.thickness = curr.value;\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirection = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 100:\r\n                break;\r\n            default: // check common entity attributes\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/vertex.js\n\r\n\r\n\r\nfunction vertex_EntityParser() {}\r\n\r\nvertex_EntityParser.ForEntityName = 'VERTEX';\r\n\r\nvertex_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10:\t// X\r\n                entity.x = curr.value;\r\n                break;\r\n            case 20: // Y\r\n                entity.y = curr.value;\r\n                break;\r\n            case 30: // Z\r\n                entity.z = curr.value;\r\n                break;\r\n            case 40: // start width\r\n                break;\r\n            case 41: // end width\r\n                break;\r\n            case 42: // bulge\r\n                if(curr.value != 0) entity.bulge = curr.value;\r\n                break;\r\n            case 70: // flags\r\n                entity.curveFittingVertex = (curr.value & 1) !== 0;\r\n                entity.curveFitTangent = (curr.value & 2) !== 0;\r\n                entity.splineVertex = (curr.value & 8) !== 0;\r\n                entity.splineControlPoint = (curr.value & 16) !== 0;\r\n                entity.threeDPolylineVertex = (curr.value & 32) !== 0;\r\n                entity.threeDPolylineMesh = (curr.value & 64) !== 0;\r\n                entity.polyfaceMeshVertex = (curr.value & 128) !== 0;\r\n                break;\r\n            case 50: // curve fit tangent direction\r\n                break;\r\n            case 71: // polyface mesh vertex index\r\n                entity.faceA = curr.value;\r\n                break;\r\n            case 72: // polyface mesh vertex index\r\n                entity.faceB = curr.value;\r\n                break;\r\n            case 73: // polyface mesh vertex index\r\n                entity.faceC = curr.value;\r\n                break;\r\n            case 74: // polyface mesh vertex index\r\n                entity.faceD = curr.value;\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        \r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/polyline.js\n\r\n\r\n\r\n\r\nfunction polyline_EntityParser() {}\r\n\r\npolyline_EntityParser.ForEntityName = 'POLYLINE';\r\n\r\npolyline_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity = { type: curr.value, vertices: [] };\r\n\t\tcurr = scanner.next();\r\n\t\twhile(curr !== 'EOF') {\r\n\t\t\tif(curr.code === 0) break;\r\n\r\n\t\t\tswitch(curr.code) {\r\n                case 10: // always 0\r\n                    break;\r\n\t\t\t\tcase 20: // always 0\r\n                    break;\r\n\t\t\t\tcase 30: // elevation\r\n                    break;\r\n\t\t\t\tcase 39: // thickness\r\n                    entity.thickness = curr.value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 40: // start width\r\n                    break;\r\n\t\t\t\tcase 41: // end width\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 70:\r\n\t\t\t\t\tentity.shape = (curr.value & 1) !== 0;\r\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\r\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\r\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\r\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\r\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\r\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\r\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 71: // Polygon mesh M vertex count\r\n                    break;\r\n\t\t\t\tcase 72: // Polygon mesh N vertex count\r\n                    break;\r\n\t\t\t\tcase 73: // Smooth surface M density\r\n                    break;\r\n\t\t\t\tcase 74: // Smooth surface N density\r\n                    break;\r\n\t\t\t\tcase 75: // Curves and smooth surface type\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 210:\r\n                    entity.extrusionDirection = ParseHelpers_parsePoint(scanner);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tcheckCommonEntityProperties(entity, curr);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcurr = scanner.next();\r\n\t\t}\r\n\r\n\t\tentity.vertices = parsePolylineVertices(scanner, curr);\r\n\r\n\t\treturn entity;\r\n};\r\n\r\nfunction parsePolylineVertices(scanner, curr) {\r\n    var vertexParser = new vertex_EntityParser();\r\n\r\n    var vertices = [];\r\n    while (!scanner.isEOF()) {\r\n        if (curr.code === 0) {\r\n            if (curr.value === 'VERTEX') {\r\n                vertices.push(vertexParser.parseEntity(scanner, curr));\r\n                curr = scanner.lastReadGroup;\r\n            } else if (curr.value === 'SEQEND') {\r\n                parseSeqEnd(scanner, curr);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return vertices;\r\n};\r\n\r\nfunction parseSeqEnd(scanner, curr) {\r\n    var entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr != 'EOF') {\r\n        if (curr.code == 0) break;\r\n        checkCommonEntityProperties(entity, curr);\r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/solid.js\n\r\n\r\n\r\nfunction solid_EntityParser() {}\r\n\r\nsolid_EntityParser.ForEntityName = 'SOLID';\r\n\r\nsolid_EntityParser.prototype.parseEntity = function(scanner, currentGroup) {\r\n    var entity;\r\n    entity = { type: currentGroup.value };\r\n    entity.points = [];\r\n    currentGroup = scanner.next();\r\n    while(currentGroup !== 'EOF') {\r\n        if(currentGroup.code === 0) break;\r\n\r\n        switch(currentGroup.code) {\r\n            case 10:\r\n                entity.points[0] = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 11:\r\n                entity.points[1] = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 12:\r\n                entity.points[2] = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 13:\r\n                entity.points[3] = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 210:\r\n                entity.extrusionDirection = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            default: // check common entity attributes\r\n                checkCommonEntityProperties(entity, currentGroup);\r\n                break;\r\n        }\r\n        currentGroup = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/spline.js\n\r\n\r\n\r\nfunction spline_EntityParser() {}\r\n\r\nspline_EntityParser.ForEntityName = 'SPLINE';\r\n\r\nspline_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n    entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF')\r\n    {\r\n        if(curr.code === 0) break;\r\n\r\n        switch(curr.code) {\r\n            case 10:\r\n                if (!entity.controlPoints) entity.controlPoints = [];\r\n                entity.controlPoints.push(ParseHelpers_parsePoint(scanner));\r\n                break;\r\n            case 11:\r\n                if (!entity.fitPoints) entity.fitPoints = [];\r\n                entity.fitPoints.push(ParseHelpers_parsePoint(scanner));\r\n                break;\r\n            case 12:\r\n                entity.startTangent = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 13:\r\n                entity.endTangent = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40:\r\n                if (!entity.knotValues) entity.knotValues = [];\r\n                entity.knotValues.push(curr.value);\r\n                break;\r\n            case 70:\r\n                if ((curr.value & 1) != 0) entity.closed = true;\r\n                if ((curr.value & 2) != 0) entity.periodic = true;\r\n                if ((curr.value & 4) != 0) entity.rational = true;\r\n                if ((curr.value & 8) != 0) entity.planar = true;\r\n                if ((curr.value & 16) != 0) \r\n                {\r\n                    entity.planar = true;\r\n                    entity.linear = true;\r\n                }\r\n                break;\r\n                \r\n            case 71:\r\n                entity.degreeOfSplineCurve = curr.value;\r\n                break;\r\n            case 72:\r\n                entity.numberOfKnots = curr.value;\r\n                break;\r\n            case 73:\r\n                entity.numberOfControlPoints = curr.value;\r\n                break;\r\n            case 74:\r\n                entity.numberOfFitPoints = curr.value;\r\n                break;\r\n            case 210:\r\n                entity.normalVector = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            default:\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n\r\n    return entity;\r\n};\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/entities/text.js\n\r\n\r\n\r\nfunction text_EntityParser() {}\r\n\r\ntext_EntityParser.ForEntityName = 'TEXT';\r\n\r\ntext_EntityParser.prototype.parseEntity = function(scanner, curr) {\r\n    var entity;\r\n\t\tentity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while(curr !== 'EOF') {\r\n        if(curr.code === 0) break;\r\n        switch(curr.code) {\r\n            case 10: // X coordinate of 'first alignment point'\r\n                entity.startPoint = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 11: // X coordinate of 'second alignment point'\r\n                entity.endPoint = ParseHelpers_parsePoint(scanner);\r\n                break;\r\n            case 40: // Text height\r\n                entity.textHeight = curr.value;\r\n                break;\r\n            case 41:\r\n                entity.xScale = curr.value;\r\n                break;\r\n            case 50: // Rotation in degrees\r\n                entity.rotation = curr.value;\r\n                break;\r\n            case 1: // Text\r\n                entity.text = curr.value;\r\n                break;\r\n            // NOTE: 72 and 73 are meaningless without 11 (second alignment point)\r\n            case 72: // Horizontal alignment\r\n                entity.halign = curr.value;\r\n                break;\r\n            case 73: // Vertical alignment\r\n                entity.valign = curr.value;\r\n                break;\r\n            default: // check common entity attributes\r\n                checkCommonEntityProperties(entity, curr);\r\n                break;\r\n        }\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n};\n// EXTERNAL MODULE: ./node_modules/loglevel/lib/loglevel.js\nvar loglevel = __webpack_require__(1);\nvar loglevel_default = /*#__PURE__*/__webpack_require__.n(loglevel);\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/DxfParser.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import Vertex from './entities/';\r\n\r\n\r\n\r\n//log.setLevel('trace');\r\n//log.setLevel('debug');\r\n//log.setLevel('info');\r\n//log.setLevel('warn');\r\nloglevel_default.a.setLevel('error');\r\n//log.setLevel('silent');\r\n\r\nfunction registerDefaultEntityHandlers(dxfParser) {\r\n\t// Supported entities here (some entity code is still being refactored into this flow)\r\n\tdxfParser.registerEntityHandler(EntityParser);\r\n\tdxfParser.registerEntityHandler(arc_EntityParser);\r\n\tdxfParser.registerEntityHandler(attdef_EntityParser);\r\n\tdxfParser.registerEntityHandler(circle_EntityParser);\r\n\tdxfParser.registerEntityHandler(dimension_EntityParser);\r\n\tdxfParser.registerEntityHandler(ellipse_EntityParser);\r\n\tdxfParser.registerEntityHandler(insert_EntityParser);\r\n\tdxfParser.registerEntityHandler(line_EntityParser);\r\n\tdxfParser.registerEntityHandler(lwpolyline_EntityParser);\r\n\tdxfParser.registerEntityHandler(mtext_EntityParser);\r\n\tdxfParser.registerEntityHandler(point_EntityParser);\r\n\tdxfParser.registerEntityHandler(polyline_EntityParser);\r\n\tdxfParser.registerEntityHandler(solid_EntityParser);\r\n\tdxfParser.registerEntityHandler(spline_EntityParser);\r\n\tdxfParser.registerEntityHandler(text_EntityParser);\r\n\t//dxfParser.registerEntityHandler(require('./entities/vertex'));\r\n}\r\n\r\nfunction DxfParser() {\r\n\tthis._entityHandlers = {};\r\n\r\n\tregisterDefaultEntityHandlers(this);\r\n}\r\n\r\nDxfParser.prototype.parse = function(source, done) {\r\n\tthrow new Error(\"read() not implemented. Use readSync()\");\r\n};\r\n\r\nDxfParser.prototype.registerEntityHandler = function(handlerType) {\r\n\tvar instance = new handlerType();\r\n\tthis._entityHandlers[handlerType.ForEntityName] = instance;\r\n}\r\n\r\nDxfParser.prototype.parseSync = function(source) {\r\n\tif(typeof(source) === 'string') {\r\n\t\treturn this._parse(source);\r\n\t}else {\r\n\t\tconsole.error('Cannot read dxf source of type `' + typeof(source));\r\n\t\treturn null;\r\n\t}\r\n};\r\n\r\nDxfParser.prototype.parseStream = function(stream, done) {\r\n\r\n\tvar dxfString = \"\";\r\n\tvar self = this;\r\n\r\n\tstream.on('data', onData);\r\n\tstream.on('end', onEnd);\r\n\tstream.on('error', onError);\r\n\r\n\tfunction onData(chunk) {\r\n\t\tdxfString += chunk;\r\n\t}\r\n\r\n\tfunction onEnd() {\r\n\t\ttry {\r\n\t\t\tvar dxf = self._parse(dxfString);\r\n\t\t}catch(err) {\r\n\t\t\treturn done(err);\r\n\t\t}\r\n\t\tdone(null, dxf);\r\n\t}\r\n\r\n\tfunction onError(err) {\r\n\t\tdone(err);\r\n\t}\r\n};\r\n\r\nDxfParser.prototype._parse = function(dxfString) {\r\n\tvar scanner, curr, dxf = {}, lastHandle = 0;\r\n\tvar dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\r\n\r\n\tscanner = new DxfArrayScanner(dxfLinesArray);\r\n\tif(!scanner.hasNext()) throw Error('Empty file');\r\n\r\n\tvar self = this;\r\n\r\n\tvar parseAll = function() {\r\n\t\tcurr = scanner.next();\r\n\t\twhile(!scanner.isEOF()) {\r\n\t\t\tif(curr.code === 0 && curr.value === 'SECTION') {\r\n\t\t\t\tcurr = scanner.next();\r\n\r\n\t\t\t\t// Be sure we are reading a section code\r\n\t\t\t\tif (curr.code !== 2) {\r\n\t\t\t\t\tconsole.error('Unexpected code %s after 0:SECTION', debugCode(curr));\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (curr.value === 'HEADER') {\r\n\t\t\t\t\tloglevel_default.a.debug('> HEADER');\r\n\t\t\t\t\tdxf.header = parseHeader();\r\n\t\t\t\t\tloglevel_default.a.debug('<');\r\n\t\t\t\t} else if (curr.value === 'BLOCKS') {\r\n\t\t\t\t\tloglevel_default.a.debug('> BLOCKS');\r\n\t\t\t\t\tdxf.blocks = parseBlocks();\r\n\t\t\t\t\tloglevel_default.a.debug('<');\r\n\t\t\t\t} else if(curr.value === 'ENTITIES') {\r\n\t\t\t\t\tloglevel_default.a.debug('> ENTITIES');\r\n\t\t\t\t\tdxf.entities = parseEntities(false);\r\n\t\t\t\t\tloglevel_default.a.debug('<');\r\n\t\t\t\t} else if(curr.value === 'TABLES') {\r\n\t\t\t\t\tloglevel_default.a.debug('> TABLES');\r\n\t\t\t\t\tdxf.tables = parseTables();\r\n\t\t\t\t\tloglevel_default.a.debug('<');\r\n\t\t\t\t} else if(curr.value === 'EOF') {\r\n\t\t\t\t\tloglevel_default.a.debug('EOF');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tloglevel_default.a.warn('Skipping section \\'%s\\'', curr.value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t\t// If is a new section\r\n\t\t}\r\n\t};\r\n\r\n\tvar groupIs = function(code, value) {\r\n\t\treturn curr.code === code && curr.value === value;\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @return {object} header\r\n\t */\r\n\tvar parseHeader = function() {\r\n\t\t// interesting variables:\r\n\t\t//  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\r\n\t\t// http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\r\n\t\t// Also see VPORT table entries\r\n\t\tvar currVarName = null, currVarValue = null;\r\n\t\tvar header = {};\r\n\t\t// loop through header variables\r\n\t\tcurr = scanner.next();\r\n\r\n\t\twhile(true) {\r\n\t\t\tif(groupIs(0, 'ENDSEC')) {\r\n\t\t\t\tif(currVarName) header[currVarName] = currVarValue;\r\n\t\t\t\tbreak;\r\n\t\t\t} else if(curr.code === 9) {\r\n\t\t\t\tif(currVarName) header[currVarName] = currVarValue;\r\n\t\t\t\tcurrVarName = curr.value;\r\n\t\t\t\t// Filter here for particular variables we are interested in\r\n\t\t\t} else {\r\n\t\t\t\tif(curr.code === 10) {\r\n\t\t\t\t\tcurrVarValue = { x: curr.value };\r\n\t\t\t\t} else if(curr.code === 20) {\r\n\t\t\t\t\tcurrVarValue.y = curr.value;\r\n\t\t\t\t} else if(curr.code === 30) {\r\n\t\t\t\t\tcurrVarValue.z = curr.value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrVarValue = curr.value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurr = scanner.next();\r\n\t\t}\r\n\t\t// console.log(util.inspect(header, { colors: true, depth: null }));\r\n\t\tcurr = scanner.next(); // swallow up ENDSEC\r\n\t\treturn header;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\tvar parseBlocks = function() {\r\n\t\tvar blocks = {}, block;\r\n\r\n        curr = scanner.next();\r\n\r\n\t\twhile(curr.value !== 'EOF') {\r\n\t\t\tif(groupIs(0, 'ENDSEC')) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif(groupIs(0, 'BLOCK')) {\r\n\t\t\t\tloglevel_default.a.debug('block {');\r\n\t\t\t\tblock = parseBlock();\r\n\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\tensureHandle(block);\r\n                if(!block.name)\r\n                    loglevel_default.a.error('block with handle \"' + block.handle + '\" is missing a name.');\r\n\t\t\t\telse\r\n                    blocks[block.name] = block;\r\n\t\t\t} else {\r\n\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn blocks;\r\n\t};\r\n\r\n\tvar parseBlock = function() {\r\n\t\tvar block = {};\r\n\t\tcurr = scanner.next();\r\n\r\n\t\twhile(curr.value !== 'EOF') {\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tblock.xrefPath = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tblock.name = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tblock.name2 = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tblock.handle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 8:\r\n\t\t\t\t\tblock.layer = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 10:\r\n\t\t\t\t\tblock.position = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 67:\r\n\t\t\t\t\tblock.paperSpace = (curr.value && curr.value == 1) ? true : false;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 70:\r\n\t\t\t\t\tif (curr.value != 0) {\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\r\n\t\t\t\t\t\t//if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\r\n\t\t\t\t\t\tblock.type = curr.value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 100:\r\n\t\t\t\t\t// ignore class markers\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 330:\r\n\t\t\t\t\tblock.ownerHandle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tif(curr.value == 'ENDBLK')\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tblock.entities = parseEntities(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\r\n\t\t\tif(groupIs(0, 'ENDBLK')) {\r\n\t\t\t\tcurr = scanner.next();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn block;\r\n\t};\r\n\r\n\t/**\r\n\t * parseTables\r\n\t * @return {Object} Object representing tables\r\n\t */\r\n\tvar parseTables = function() {\r\n\t\tvar tables = {};\r\n\t\tcurr = scanner.next();\r\n\t\twhile(curr.value !== 'EOF') {\r\n\t\t\tif(groupIs(0, 'ENDSEC'))\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tif(groupIs(0, 'TABLE')) {\r\n\t\t\t\tcurr = scanner.next();\r\n\r\n\t\t\t\tvar tableDefinition = tableDefinitions[curr.value];\r\n\t\t\t\tif(tableDefinition) {\r\n\t\t\t\t\tloglevel_default.a.debug(curr.value + ' Table {');\r\n\t\t\t\t\ttables[tableDefinitions[curr.value].tableName] = parseTable();\r\n\t\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tloglevel_default.a.debug('Unhandled Table ' + curr.value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// else ignored\r\n\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcurr = scanner.next();\r\n\t\treturn tables;\r\n\t};\r\n\r\n\tconst END_OF_TABLE_VALUE = 'ENDTAB';\r\n\r\n\tvar parseTable = function() {\r\n\t\tvar tableDefinition = tableDefinitions[curr.value],\r\n\t\t\ttable = {},\r\n\t\t\texpectedCount = 0,\r\n\t\t\tactualCount;\r\n\r\n\t\tcurr = scanner.next();\r\n\t\twhile(!groupIs(0, END_OF_TABLE_VALUE)) {\r\n\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\ttable.handle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 330:\r\n\t\t\t\t\ttable.ownerHandle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 100:\r\n\t\t\t\t\tif(curr.value === 'AcDbSymbolTable') {\r\n\t\t\t\t\t\t// ignore\r\n\t\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 70:\r\n\t\t\t\t\texpectedCount = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tif(curr.value === tableDefinition.dxfSymbolName) {\r\n\t\t\t\t\t\ttable[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar tableRecords = table[tableDefinition.tableRecordsProperty];\r\n\t\tif(tableRecords) {\r\n\t\t\tif(tableRecords.constructor === Array){\r\n\t\t\t\tactualCount = tableRecords.length;\r\n\t\t\t} else if(typeof(tableRecords) === 'object') {\r\n\t\t\t\tactualCount = Object.keys(tableRecords).length;\r\n\t\t\t}\r\n\t\t\tif(expectedCount !== actualCount) loglevel_default.a.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\r\n\t\t}\r\n\t\tcurr = scanner.next();\r\n\t\treturn table;\r\n\t};\r\n\r\n\tvar parseViewPortRecords = function() {\r\n\t\tvar viewPorts = [], // Multiple table entries may have the same name indicating a multiple viewport configuration\r\n\t\t\tviewPort = {};\r\n\r\n\t\tloglevel_default.a.debug('ViewPort {');\r\n\t\tcurr = scanner.next();\r\n\t\twhile(!groupIs(0, END_OF_TABLE_VALUE)) {\r\n\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 2: // layer name\r\n\t\t\t\t\tviewPort.name = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 10:\r\n\t\t\t\t\tviewPort.lowerLeftCorner = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 11:\r\n\t\t\t\t\tviewPort.upperRightCorner = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 12:\r\n\t\t\t\t\tviewPort.center = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 13:\r\n\t\t\t\t\tviewPort.snapBasePoint = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 14:\r\n\t\t\t\t\tviewPort.snapSpacing = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 15:\r\n\t\t\t\t\tviewPort.gridSpacing = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 16:\r\n\t\t\t\t\tviewPort.viewDirectionFromTarget = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 17:\r\n\t\t\t\t\tviewPort.viewTarget = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 42:\r\n\t\t\t\t\tviewPort.lensLength = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 43:\r\n\t\t\t\t\tviewPort.frontClippingPlane = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 44:\r\n\t\t\t\t\tviewPort.backClippingPlane = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 45:\r\n\t\t\t\t\tviewPort.viewHeight = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 50:\r\n\t\t\t\t\tviewPort.snapRotationAngle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 51:\r\n\t\t\t\t\tviewPort.viewTwistAngle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n                case 79:\r\n                    viewPort.orthographicType = curr.value;\r\n                    curr = scanner.next();\r\n                    break;\r\n\t\t\t\tcase 110:\r\n\t\t\t\t\tviewPort.ucsOrigin = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 111:\r\n\t\t\t\t\tviewPort.ucsXAxis = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 112:\r\n\t\t\t\t\tviewPort.ucsYAxis = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 110:\r\n\t\t\t\t\tviewPort.ucsOrigin = parsePoint();\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 281:\r\n\t\t\t\t\tviewPort.renderMode = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 281:\r\n\t\t\t\t\t// 0 is one distant light, 1 is two distant lights\r\n\t\t\t\t\tviewPort.defaultLightingType = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 292:\r\n\t\t\t\t\tviewPort.defaultLightingOn = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 330:\r\n\t\t\t\t\tviewPort.ownerHandle = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\r\n\t\t\t\tcase 421:\r\n\t\t\t\tcase 431:\r\n\t\t\t\t\tviewPort.ambientColor = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\t// New ViewPort\r\n\t\t\t\t\tif(curr.value === 'VPORT') {\r\n\t\t\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\t\t\tviewPorts.push(viewPort);\r\n\t\t\t\t\t\tloglevel_default.a.debug('ViewPort {');\r\n\t\t\t\t\t\tviewPort = {};\r\n\t\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Note: do not call scanner.next() here,\r\n\t\t//  parseTable() needs the current group\r\n\t\tloglevel_default.a.debug('}');\r\n\t\tviewPorts.push(viewPort);\r\n\r\n\t\treturn viewPorts;\r\n\t};\r\n\r\n\tvar parseLineTypes = function() {\r\n\t\tvar ltypes = {},\r\n\t\t\tltypeName,\r\n\t\t\tltype = {},\r\n\t\t\tlength;\r\n\r\n\t\tloglevel_default.a.debug('LType {');\r\n\t\tcurr = scanner.next();\r\n\t\twhile(!groupIs(0, 'ENDTAB')) {\r\n\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tltype.name = curr.value;\r\n\t\t\t\t\tltypeName = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tltype.description = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 73: // Number of elements for this line type (dots, dashes, spaces);\r\n\t\t\t\t\tlength = curr.value;\r\n\t\t\t\t\tif(length > 0) ltype.pattern = [];\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 40: // total pattern length\r\n\t\t\t\t\tltype.patternLength = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 49:\r\n\t\t\t\t\tltype.pattern.push(curr.value);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\t\tif(length > 0 && length !== ltype.pattern.length) loglevel_default.a.warn('lengths do not match on LTYPE pattern');\r\n\t\t\t\t\tltypes[ltypeName] = ltype;\r\n\t\t\t\t\tltype = {};\r\n\t\t\t\t\tloglevel_default.a.debug('LType {');\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tloglevel_default.a.debug('}');\r\n\t\tltypes[ltypeName] = ltype;\r\n\t\treturn ltypes;\r\n\t};\r\n\r\n\tvar parseLayers = function() {\r\n\t\tvar layers = {},\r\n\t\t\tlayerName,\r\n\t\t\tlayer = {};\r\n\r\n\t\tloglevel_default.a.debug('Layer {');\r\n\t\tcurr = scanner.next();\r\n\t\twhile(!groupIs(0, 'ENDTAB')) {\r\n\r\n\t\t\tswitch(curr.code) {\r\n\t\t\t\tcase 2: // layer name\r\n\t\t\t\t\tlayer.name = curr.value;\r\n\t\t\t\t\tlayerName = curr.value;\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 62: // color, visibility\r\n\t\t\t\t\tlayer.visible = curr.value >= 0;\r\n\t\t\t\t\t// TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\r\n\t\t\t\t\tlayer.colorIndex = Math.abs(curr.value);\r\n\t\t\t\t\tlayer.color = DxfParser_getAcadColor(layer.colorIndex);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 70: // frozen layer\r\n\t\t\t\t\tlayer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\t// New Layer\r\n\t\t\t\t\tif(curr.value === 'LAYER') {\r\n\t\t\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\t\t\tlayers[layerName] = layer;\r\n\t\t\t\t\t\tloglevel_default.a.debug('Layer {');\r\n\t\t\t\t\t\tlayer = {};\r\n\t\t\t\t\t\tlayerName = undefined;\r\n\t\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tlogUnhandledGroup(curr);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Note: do not call scanner.next() here,\r\n\t\t//  parseLayerTable() needs the current group\r\n\t\tloglevel_default.a.debug('}');\r\n\t\tlayers[layerName] = layer;\r\n\r\n\t\treturn layers;\r\n\t};\r\n\r\n\tvar tableDefinitions = {\r\n\t\tVPORT: {\r\n\t\t\ttableRecordsProperty: 'viewPorts',\r\n\t\t\ttableName: 'viewPort',\r\n\t\t\tdxfSymbolName: 'VPORT',\r\n\t\t\tparseTableRecords: parseViewPortRecords\r\n\t\t},\r\n\t\tLTYPE: {\r\n\t\t\ttableRecordsProperty: 'lineTypes',\r\n\t\t\ttableName: 'lineType',\r\n\t\t\tdxfSymbolName: 'LTYPE',\r\n\t\t\tparseTableRecords: parseLineTypes\r\n\t\t},\r\n\t\tLAYER: {\r\n\t\t\ttableRecordsProperty: 'layers',\r\n\t\t\ttableName: 'layer',\r\n\t\t\tdxfSymbolName: 'LAYER',\r\n\t\t\tparseTableRecords: parseLayers\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Is called after the parser first reads the 0:ENTITIES group. The scanner\r\n\t * should be on the start of the first entity already.\r\n\t * @return {Array} the resulting entities\r\n\t */\r\n\tvar parseEntities = function(forBlock) {\r\n\t\tvar entities = [];\r\n\r\n\t\tvar endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\r\n\r\n\t\tif (!forBlock) {\r\n\t\t\tcurr = scanner.next();\r\n\t\t}\r\n\t\twhile(true) {\r\n\r\n\t\t\tif(curr.code === 0) {\r\n\t\t\t\tif(curr.value === endingOnValue) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar entity;\r\n\t\t\t\tvar handler = self._entityHandlers[curr.value];\r\n\t\t\t\tif(handler != null) {\r\n\t\t\t\t\tloglevel_default.a.debug(curr.value + ' {');\r\n\t\t\t\t\tentity = handler.parseEntity(scanner, curr);\r\n\t\t\t\t\tcurr = scanner.lastReadGroup;\r\n\t\t\t\t\tloglevel_default.a.debug('}');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tloglevel_default.a.warn('Unhandled entity ' + curr.value);\r\n\t\t\t\t\tcurr = scanner.next();\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tensureHandle(entity);\r\n\t\t\t\tentities.push(entity);\r\n\t\t\t} else {\r\n\t\t\t\t// ignored lines from unsupported entity\r\n\t\t\t\tcurr = scanner.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(endingOnValue == 'ENDSEC') curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\r\n\t\treturn entities;\r\n\t};\r\n\r\n\t/**\r\n\t * Parses a 2D or 3D point, returning it as an object with x, y, and\r\n\t * (sometimes) z property if it is 3D. It is assumed the current group\r\n\t * is x of the point being read in, and scanner.next() will return the\r\n\t * y. The parser will determine if there is a z point automatically.\r\n\t * @return {Object} The 2D or 3D point as an object with x, y[, z]\r\n\t */\r\n\tvar parsePoint = function() {\r\n\t\tvar point = {},\r\n\t\t\tcode = curr.code;\r\n\r\n\t\tpoint.x = curr.value;\r\n\r\n\t\tcode += 10;\r\n\t\tcurr = scanner.next();\r\n\t\tif(curr.code != code)\r\n\t\t\tthrow new Error('Expected code for point value to be ' + code +\r\n\t\t\t' but got ' + curr.code + '.');\r\n\t\tpoint.y = curr.value;\r\n\r\n\t\tcode += 10;\r\n\t\tcurr = scanner.next();\r\n\t\tif(curr.code != code)\r\n\t\t{\r\n\t\t\tscanner.rewind();\r\n\t\t\treturn point;\r\n\t\t}\r\n\t\tpoint.z = curr.value;\r\n\t\t\r\n\t\treturn point;\r\n\t};\r\n\r\n\tvar ensureHandle = function(entity) {\r\n\t\tif(!entity) throw new TypeError('entity cannot be undefined or null');\r\n\r\n\t\tif(!entity.handle) entity.handle = lastHandle++;\r\n\t};\r\n\r\n\tparseAll();\r\n\treturn dxf;\r\n};\r\n\r\nfunction logUnhandledGroup(curr) {\r\n\tloglevel_default.a.debug('unhandled group ' + debugCode(curr));\r\n}\r\n\r\n\r\nfunction debugCode(curr) {\r\n\treturn curr.code + ':' + curr.value;\r\n}\r\n\r\n/**\r\n * Returns the truecolor value of the given AutoCad color index value\r\n * @return {Number} truecolor value as a number\r\n */\r\nfunction DxfParser_getAcadColor(index) {\r\n\treturn AutoCadColorIndex[index];\r\n}\r\n\r\nconst BLOCK_ANONYMOUS_FLAG = 1;\r\nconst BLOCK_NON_CONSTANT_FLAG = 2;\r\nconst BLOCK_XREF_FLAG = 4;\r\nconst BLOCK_XREF_OVERLAY_FLAG = 8;\r\nconst BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\r\nconst BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\r\nconst BLOCK_REFERENCED_XREF = 64;\r\n\r\n\r\n/* Notes */\r\n// Code 6 of an entity indicates inheritance of properties (eg. color).\r\n//   BYBLOCK means inherits from block\r\n//   BYLAYER (default) mean inherits from layer\r\n\n// CONCATENATED MODULE: ./node_modules/dxf-parser/src/index.js\n\r\n\r\n/* harmony default export */ var src = (DxfParser);\n// CONCATENATED MODULE: ./src/OrbitControls.js\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n//\n// This is a drop-in replacement for (most) TrackballControls used in examples.\n// That is, include this js file and wherever you see:\n//    \tcontrols = new THREE.TrackballControls( camera );\n//      controls.target.z = 150;\n// Simple substitute \"OrbitControls\" and the control should work as-is.\n\n\n\nfunction OrbitControls( object, domElement ) {\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the control orbits around\n\t// and where it pans with respect to.\n\tthis.target = new external_THREE_[\"Vector3\"]();\n\n\t// center is old, deprecated; use \"target\" instead\n\tthis.center = this.target;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t// backwards compatibility\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\n\t// Limits to how far you can dolly in and out\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// Set to true to disable this control\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to true to disable this control\n\tthis.noPan = false;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// Set to true to disable use of the keys\n\tthis.noKeys = false;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t////////////\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new external_THREE_[\"Vector2\"]();\n\tvar rotateEnd = new external_THREE_[\"Vector2\"]();\n\tvar rotateDelta = new external_THREE_[\"Vector2\"]();\n\n\tvar panStart = new external_THREE_[\"Vector2\"]();\n\tvar panEnd = new external_THREE_[\"Vector2\"]();\n\tvar panDelta = new external_THREE_[\"Vector2\"]();\n\tvar panOffset = new external_THREE_[\"Vector3\"]();\n\n\tvar offset = new external_THREE_[\"Vector3\"]();\n\n\tvar dollyStart = new external_THREE_[\"Vector2\"]();\n\tvar dollyEnd = new external_THREE_[\"Vector2\"]();\n\tvar dollyDelta = new external_THREE_[\"Vector2\"]();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new external_THREE_[\"Vector3\"]();\n\n\tvar lastPosition = new external_THREE_[\"Vector3\"]();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\tvar state = STATE.NONE;\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start'};\n\tvar endEvent = { type: 'end'};\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\tpanOffset.multiplyScalar( - distance );\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\tpanOffset.multiplyScalar( distance );\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\t\n\t// pass in x,y of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( deltaX, deltaY ) {\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( scope.object.fov !== undefined ) {\n\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\n\t\t} else if ( scope.object.top !== undefined ) {\n            \n\t\t\t// orthographic\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic or perspective\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= dollyScale;\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= dollyScale;\n\n\t};\n\n\tthis.update = function () {\n        \n        if(scope.object.top !== undefined) {\n            this.object.top = (scale*this.object.top);\n            this.object.bottom = (scale*this.object.bottom);\n            this.object.left = (scale*this.object.left);\n            this.object.right = (scale*this.object.right);\n            \n            this.object.updateProjectionMatrix();\n\n        }\n            \n\n\t\tvar position = this.object.position;\n\n\t\toffset.copy( position ).sub( this.target );\n//\n//\t\t// angle from z-axis around y-axis\n//\n//\t\tvar theta = Math.atan2( offset.x, offset.z );\n//\n//\t\t// angle from y-axis\n//\n//\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n//\n//\t\tif ( this.autoRotate ) {\n//\n//\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n//\n//\t\t}\n//\n//\t\ttheta += thetaDelta;\n//\t\tphi += phiDelta;\n//\n//\t\t// restrict phi to be between desired limits\n//\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n//\n//\t\t// restrict phi to be betwee EPS and PI-EPS\n//\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n//\n//\t\tvar radius = offset.length() * scale;\n//\n//\t\t// restrict radius to be between desired limits\n//\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n//\t\t\n//\t\t// move target to panned location\n\t\tthis.target.add( pan );\n//\t\t\n//\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n//\t\toffset.y = radius * Math.cos( phi );\n//\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n//\n\t\tposition.copy( this.target ).add( offset );\n\n\t\tthis.object.lookAt( this.target );\n\n\n//\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 || scale !== 1 ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n//\t\t\tlastPosition.copy( this.object.position );\n\n//\t\t}\n        \n//        thetaDelta = 0;\n//\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set( 0, 0, 0 );\n\n\t};\n\n\n\tthis.reset = function () {\n\n\t\tstate = STATE.NONE;\n\n\t\tthis.target.copy( this.target0 );\n\t\tthis.object.position.copy( this.position0 );\n\n\t\tthis.update();\n\n\t};\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === 0 ) {\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 1 ) {\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 2 ) {\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tscope.domElement.addEventListener( 'mousemove', onMouseMove, false );\n\t\tscope.domElement.addEventListener( 'mouseup', onMouseUp, false );\n\t\tscope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\n\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tscope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail !== undefined ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\n\t\tscope.update();\n\t\tscope.dispatchEvent( startEvent );\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\t\t\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tscope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\t\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n};\n\nOrbitControls.prototype = Object.create( external_THREE_[\"EventDispatcher\"].prototype );\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n// Three.js extension functions. Webpack doesn't seem to like it if we modify the THREE object directly.\nvar THREEx = { Math: {} };\n/**\n * Returns the angle in radians of the vector (p1,p2). In other words, imagine\n * putting the base of the vector at coordinates (0,0) and finding the angle\n * from vector (1,0) to (p1,p2).\n * @param  {Object} p1 start point of the vector\n * @param  {Object} p2 end point of the vector\n * @return {Number} the angle\n */\nTHREEx.Math.angle2 = function(p1, p2) {\n\tvar v1 = new external_THREE_[\"Vector2\"](p1.x, p1.y);\n\tvar v2 = new external_THREE_[\"Vector2\"](p2.x, p2.y);\n\tv2.sub(v1); // sets v2 to be our chord\n\tv2.normalize();\n\tif(v2.y < 0) return -Math.acos(v2.x);\n\treturn Math.acos(v2.x);\n};\n\n\nTHREEx.Math.polar = function(point, distance, angle) {\n\tvar result = {};\n\tresult.x = point.x + distance * Math.cos(angle);\n\tresult.y = point.y + distance * Math.sin(angle);\n\treturn result;\n};\n\n/**\n * Calculates points for a curve between two points\n * @param startPoint - the starting point of the curve\n * @param endPoint - the ending point of the curve\n * @param bulge - a value indicating how much to curve\n * @param segments - number of segments between the two given points\n */\nTHREEx.BulgeGeometry = function ( startPoint, endPoint, bulge, segments ) {\n\n\tvar vertex, i,\n\t\tcenter, p0, p1, angle,\n\t\tradius, startAngle,\n\t\tthetaAngle;\n\n\texternal_THREE_[\"Geometry\"].call( this );\n\n\tthis.startPoint = p0 = startPoint ? new external_THREE_[\"Vector2\"](startPoint.x, startPoint.y) : new external_THREE_[\"Vector2\"](0,0);\n\tthis.endPoint = p1 = endPoint ? new external_THREE_[\"Vector2\"](endPoint.x, endPoint.y) : new external_THREE_[\"Vector2\"](1,0);\n\tthis.bulge = bulge = bulge || 1;\n\n\tangle = 4 * Math.atan(bulge);\n\tradius = p0.distanceTo(p1) / 2 / Math.sin(angle/2);\n\tcenter = THREEx.Math.polar(startPoint, radius, THREEx.Math.angle2(p0,p1) + (Math.PI / 2 - angle/2));\n\n\tthis.segments = segments = segments || Math.max( Math.abs(Math.ceil(angle/(Math.PI/18))), 6); // By default want a segment roughly every 10 degrees\n\tstartAngle = THREEx.Math.angle2(center, p0);\n\tthetaAngle = angle / segments;\n\n\n\tthis.vertices.push(new external_THREE_[\"Vector3\"](p0.x, p0.y, 0));\n\n\tfor(i = 1; i <= segments - 1; i++) {\n\n\t\tvertex = THREEx.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);\n\n\t\tthis.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\n\n\t}\n\n};\n\nTHREEx.BulgeGeometry.prototype = Object.create( external_THREE_[\"Geometry\"].prototype );\n\n/**\n * THREE.Loader implementation for DXF files\n * \n * @param {*} manager THREE.LoadingManager \n * \n * @see https://threejs.org/docs/#api/en/loaders/Loader\n * @author Sourabh Soni / https://www.prolincur.com\n */\nconst DXFLoader = function (manager) {\n    external_THREE_[\"Loader\"].call(this, manager);\n    this.font = null\n}\n\nDXFLoader.prototype = Object.assign( Object.create( external_THREE_[\"Loader\"].prototype ), {\n    constructor: DXFLoader,\n\n    setFont: function ( font ) {\n\t\tthis.font = font;\n\t\treturn this;\n    },\n    \n    load: function ( url, onLoad, onProgress, onError ) {\n        var scope = this;\n\t\tvar loader = new external_THREE_[\"FileLoader\"]( scope.manager );\n\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, ( text ) => {\n            try {\n                onLoad(scope.parse(text))\n            } catch (error) {\n                if (onError) {\n                    onError(error)\n                } else {\n                    console.error(error)\n                }\n                scope.manager.itemError(url)\n            }\n\t\t}, onProgress, onError );\n\n    },\n\n    parse: function ( text ) {\n        const parser = new src();\n        var dxf = parser.parseSync(text)\n        return this.loadEntities(dxf, this.font)\n    },\n\n    /**\n     *\n     * @param {Object} buffer - the dxf file content\n     * @param {Object} font - a font loaded with THREE.FontLoader \n     * @constructor\n     */\n    loadEntities: function ( data, font ) {\n\n        createLineTypeShaders(data);\n\n        var entities = []\n\n        // Create scene from dxf object (data)\n        var i, entity, obj, min_x, min_y, min_z, max_x, max_y, max_z;\n        var dims = {\n            min: { x: false, y: false, z: false},\n            max: { x: false, y: false, z: false}\n        };\n        for(i = 0; i < data.entities.length; i++) {\n            entity = data.entities[i];\n            obj = drawEntity(entity, data);\n        \n            if (obj) {\n                entities.push(obj)\n            }\n            obj = null;\n        }\n        return {\n            entities: entities,\n            dxf: data\n        }\n\n        function drawEntity(entity, data) {\n            var mesh;\n            if(entity.type === 'CIRCLE' || entity.type === 'ARC') {\n                mesh = drawArc(entity, data);\n            } else if(entity.type === 'LWPOLYLINE' || entity.type === 'LINE' || entity.type === 'POLYLINE') {\n                mesh = drawLine(entity, data);\n            } else if(entity.type === 'TEXT') {\n                mesh = drawText(entity, data);\n            } else if(entity.type === 'SOLID') {\n                mesh = drawSolid(entity, data);\n            } else if(entity.type === 'POINT') {\n                mesh = drawPoint(entity, data);\n            } else if(entity.type === 'INSERT') {\n                mesh = drawBlock(entity, data);\n            } else if(entity.type === 'SPLINE') {\n                mesh = drawSpline(entity, data);\n            } else if(entity.type === 'MTEXT') {\n                mesh = drawMtext(entity, data);\n            } else if(entity.type === 'ELLIPSE') {\n                mesh = drawEllipse(entity, data);\n            } else if(entity.type === 'DIMENSION') {\n                var dimTypeEnum = entity.dimensionType & 7;\n                if(dimTypeEnum === 0) {\n                    mesh = drawDimension(entity, data);\n                } else {\n                    console.log(\"Unsupported Dimension type: \" + dimTypeEnum);\n                }\n            }\n            else {\n                console.log(\"Unsupported Entity Type: \" + entity.type);\n            }\n            return mesh;\n        }\n\n        function drawEllipse(entity, data) {\n            var color = getColor(entity, data);\n\n            var xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x,2) + Math.pow(entity.majorAxisEndPoint.y,2));\n            var yrad = xrad*entity.axisRatio;\n            var rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);\n\n            var curve = new external_THREE_[\"EllipseCurve\"](\n                entity.center.x,  entity.center.y,\n                xrad, yrad,\n                entity.startAngle, entity.endAngle,\n                false, // Always counterclockwise\n                rotation\n            );\n\n            var points = curve.getPoints( 50 );\n            var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\n            var material = new external_THREE_[\"LineBasicMaterial\"]( {  linewidth: 1, color : color } );\n\n            // Create the final object to add to the scene\n            var ellipse = new external_THREE_[\"Line\"]( geometry, material );\n            return ellipse;\n        }\n\n        function drawMtext(entity, data) {\n            var color = getColor(entity, data);\n\n            var geometry = new external_THREE_[\"TextGeometry\"]( entity.text, {\n                font: font,\n                size: entity.height * (4/5),\n                height: 1\n            });\n            var material = new external_THREE_[\"MeshBasicMaterial\"]( {color: color} );\n            var text = new external_THREE_[\"Mesh\"]( geometry, material );\n\n            // Measure what we rendered.\n            var measure = new external_THREE_[\"Box3\"]();\n            measure.setFromObject( text );\n\n            var textWidth  = measure.max.x - measure.min.x;\n\n            // If the text ends up being wider than the box, it's supposed\n            // to be multiline. Doing that in threeJS is overkill.\n            if (textWidth > entity.width) {\n                console.log(\"Can't render this multipline MTEXT entity, sorry.\", entity);\n                return undefined;\n            }\n\n            text.position.z = 0;\n            switch (entity.attachmentPoint) {\n                case 1:\n                    // Top Left\n                    text.position.x = entity.position.x;\n                    text.position.y = entity.position.y - entity.height;\n                break;\n                case 2:\n                    // Top Center\n                    text.position.x = entity.position.x - textWidth/2;\n                    text.position.y = entity.position.y - entity.height;\n                break;\n                case 3:\n                    // Top Right\n                    text.position.x = entity.position.x - textWidth;\n                    text.position.y = entity.position.y - entity.height;\n                break;\n\n                case 4:\n                    // Middle Left\n                    text.position.x = entity.position.x;\n                    text.position.y = entity.position.y - entity.height/2;\n                break;\n                case 5:\n                    // Middle Center\n                    text.position.x = entity.position.x - textWidth/2;\n                    text.position.y = entity.position.y - entity.height/2;\n                break;\n                case 6:\n                    // Middle Right\n                    text.position.x = entity.position.x - textWidth;\n                    text.position.y = entity.position.y - entity.height/2;\n                break;\n\n                case 7:\n                    // Bottom Left\n                    text.position.x = entity.position.x;\n                    text.position.y = entity.position.y;\n                break;\n                case 8:\n                    // Bottom Center\n                    text.position.x = entity.position.x - textWidth/2;\n                    text.position.y = entity.position.y;\n                break;\n                case 9:\n                    // Bottom Right\n                    text.position.x = entity.position.x - textWidth;\n                    text.position.y = entity.position.y;\n                break;\n\n                default:\n                    return undefined;\n            };\n\n            return text;\n        }\n\n        function drawSpline(entity, data) {\n            var color = getColor(entity, data);\n\n            var points = entity.controlPoints.map(function(vec) {\n                return new external_THREE_[\"Vector2\"](vec.x, vec.y);\n            });\n\n            var interpolatedPoints = [];\n            var curve;\n            if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {\n                for(var i = 0; i + 2 < points.length; i = i + 2) {\n            if (entity.degreeOfSplineCurve === 2) {\n                            curve = new external_THREE_[\"QuadraticBezierCurve\"](points[i], points[i + 1], points[i + 2]);\n            } else {\n                curve = new external_THREE_[\"QuadraticBezierCurve3\"](points[i], points[i + 1], points[i + 2]);\n            }\n                    interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));\n                }\n            } else {\n                curve = new external_THREE_[\"SplineCurve\"](points);\n                interpolatedPoints = curve.getPoints( 100 );\n            }\n\n            var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( interpolatedPoints );\n            var material = new external_THREE_[\"LineBasicMaterial\"]( { linewidth: 1, color : color } );\n            var splineObject = new external_THREE_[\"Line\"]( geometry, material );\n\n            return splineObject;\n        }\n\n        function drawLine(entity, data) {\n            var geometry = new external_THREE_[\"Geometry\"](),\n                color = getColor(entity, data),\n                material, lineType, vertex, startPoint, endPoint, bulgeGeometry,\n                bulge, i, line;\n\n            // create geometry\n            for(i = 0; i < entity.vertices.length; i++) {\n\n                if(entity.vertices[i].bulge) {\n                    bulge = entity.vertices[i].bulge;\n                    startPoint = entity.vertices[i];\n                    endPoint = i + 1 < entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];\n\n                    bulgeGeometry = new THREEx.BulgeGeometry(startPoint, endPoint, bulge);\n\n                    geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);\n                } else {\n                    vertex = entity.vertices[i];\n                    geometry.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\n                }\n\n            }\n            if(entity.shape) geometry.vertices.push(geometry.vertices[0]);\n\n\n            // set material\n            if(entity.lineType) {\n                lineType = data.tables.lineType.lineTypes[entity.lineType];\n            }\n\n            if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\n                material = new external_THREE_[\"LineDashedMaterial\"]({ color: color, gapSize: 4, dashSize: 4});\n            } else {\n                material = new external_THREE_[\"LineBasicMaterial\"]({ linewidth: 1, color: color });\n            }\n\n            // if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\n\n            //           geometry.computeLineDistances();\n\n            //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we\n            //           // don't add diffuse to a material.\n            //           lineType.material.uniforms.diffuse = { type: 'c', value: new THREE.Color(color) };\n\n            // \tmaterial = new THREE.ShaderMaterial({\n            // \t\tuniforms: lineType.material.uniforms,\n            // \t\tvertexShader: lineType.material.vertexShader,\n            // \t\tfragmentShader: lineType.material.fragmentShader\n            // \t});\n            // }else {\n            // \tmaterial = new THREE.LineBasicMaterial({ linewidth: 1, color: color });\n            // }\n\n            line = new external_THREE_[\"Line\"](geometry, material);\n            return line;\n        }\n        \n        function drawArc(entity, data) {\n            var startAngle, endAngle;\n            if (entity.type === 'CIRCLE') {\n                startAngle = entity.startAngle || 0;\n                endAngle = startAngle + 2 * Math.PI;\n            } else {\n                startAngle = entity.startAngle;\n                endAngle = entity.endAngle;\n            }\n\n            var curve = new external_THREE_[\"ArcCurve\"](\n                0, 0,\n                entity.radius,\n                startAngle,\n                endAngle);\n\n            var points = curve.getPoints( 32 );\n            var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\n\n            var material = new external_THREE_[\"LineBasicMaterial\"]({ color: getColor(entity, data) });\n\n            var arc = new external_THREE_[\"Line\"](geometry, material);\n            arc.position.x = entity.center.x;\n            arc.position.y = entity.center.y;\n            arc.position.z = entity.center.z;\n\n            return arc;\n        }\n\n        function drawSolid(entity, data) {\n            var material, mesh, verts,\n                geometry = new external_THREE_[\"Geometry\"]();\n\n            verts = geometry.vertices;\n            verts.push(new external_THREE_[\"Vector3\"](entity.points[0].x, entity.points[0].y, entity.points[0].z));\n            verts.push(new external_THREE_[\"Vector3\"](entity.points[1].x, entity.points[1].y, entity.points[1].z));\n            verts.push(new external_THREE_[\"Vector3\"](entity.points[2].x, entity.points[2].y, entity.points[2].z));\n            verts.push(new external_THREE_[\"Vector3\"](entity.points[3].x, entity.points[3].y, entity.points[3].z));\n\n            // Calculate which direction the points are facing (clockwise or counter-clockwise)\n            var vector1 = new external_THREE_[\"Vector3\"]();\n            var vector2 = new external_THREE_[\"Vector3\"]();\n            vector1.subVectors(verts[1], verts[0]);\n            vector2.subVectors(verts[2], verts[0]);\n            vector1.cross(vector2);\n\n            // If z < 0 then we must draw these in reverse order\n            if(vector1.z < 0) {\n                geometry.faces.push(new external_THREE_[\"Face3\"](2, 1, 0));\n                geometry.faces.push(new external_THREE_[\"Face3\"](2, 3, 1));\n            } else {\n                geometry.faces.push(new external_THREE_[\"Face3\"](0, 1, 2));\n                geometry.faces.push(new external_THREE_[\"Face3\"](1, 3, 2));\n            }\n\n\n            material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\n\n            return new external_THREE_[\"Mesh\"](geometry, material);\n            \n        }\n\n        function drawText(entity, data) {\n            var geometry, material, text;\n\n            if(!font)\n                return console.warn('Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.');\n            \n            geometry = new external_THREE_[\"TextGeometry\"](entity.text, { font: font, height: 0, size: entity.textHeight || 12 });\n\n            if (entity.rotation) {\n                var zRotation = entity.rotation * Math.PI / 180;\n                geometry.rotateZ(zRotation);\n            }\n\n            material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\n\n            text = new external_THREE_[\"Mesh\"](geometry, material);\n            text.position.x = entity.startPoint.x;\n            text.position.y = entity.startPoint.y;\n            text.position.z = entity.startPoint.z;\n\n            return text;\n        }\n\n        function drawPoint(entity, data) {\n            var geometry, material, point;\n\n            geometry = new external_THREE_[\"Geometry\"]();\n\n            geometry.vertices.push(new external_THREE_[\"Vector3\"](entity.position.x, entity.position.y, entity.position.z));\n\n            // TODO: could be more efficient. PointCloud per layer?\n\n            var numPoints = 1;\n\n            var color = getColor(entity, data);\n            var colors = new Float32Array( numPoints*3 );\n            colors[0] = color.r;\n            colors[1] = color.g;\n            colors[2] = color.b;\n\n            geometry.colors = colors;\n            geometry.computeBoundingBox();\n\n            material = new external_THREE_[\"PointsMaterial\"]( { size: 0.05, vertexColors: external_THREE_[\"VertexColors\"] } );\n            point = new external_THREE_[\"Points\"](geometry, material);\n            scene.add(point);\n        }\n\n        function drawDimension(entity, data) {\n            var block = data.blocks[entity.block];\n\n            if (!block || !block.entities) return null;\n\n            var group = new external_THREE_[\"Object3D\"]();\n            // if(entity.anchorPoint) {\n            //     group.position.x = entity.anchorPoint.x;\n            //     group.position.y = entity.anchorPoint.y;\n            //     group.position.z = entity.anchorPoint.z;\n            // }\n\n            for(var i = 0; i < block.entities.length; i++) {\n                var childEntity = drawEntity(block.entities[i], data, group);\n                if(childEntity) group.add(childEntity);\n            }\n\n            return group;\n        }\n\n        function drawBlock(entity, data) {\n            var block = data.blocks[entity.name];\n            \n            if (!block.entities) return null;\n\n            var group = new external_THREE_[\"Object3D\"]()\n            \n            if(entity.xScale) group.scale.x = entity.xScale;\n            if(entity.yScale) group.scale.y = entity.yScale;\n\n            if(entity.rotation) {\n                group.rotation.z = entity.rotation * Math.PI / 180;\n            }\n\n            if(entity.position) {\n                group.position.x = entity.position.x;\n                group.position.y = entity.position.y;\n                group.position.z = entity.position.z;\n            }\n            \n            for(var i = 0; i < block.entities.length; i++) {\n                var childEntity = drawEntity(block.entities[i], data, group);\n                if(childEntity) group.add(childEntity);\n            }\n\n            return group;\n        }\n\n        function getColor(entity, data) {\n            var color = 0x000000; //default\n            if(entity.color) color = entity.color;\n            else if(data.tables && data.tables.layer && data.tables.layer.layers[entity.layer])\n                color = data.tables.layer.layers[entity.layer].color;\n                \n            if(color == null || color === 0xffffff) {\n                color = 0x000000;\n            }\n            return color;\n        }\n\n        function createLineTypeShaders(data) {\n            var ltype, type;\n            if(!data.tables || !data.tables.lineType) return;\n            var ltypes = data.tables.lineType.lineTypes;\n\n            for(type in ltypes) {\n                ltype = ltypes[type];\n                if(!ltype.pattern) continue;\n                ltype.material = createDashedLineShader(ltype.pattern);\n            }\n        }\n\n        function createDashedLineShader(pattern) {\n            var i,\n                dashedLineShader = {},\n                totalLength = 0.0;\n\n            for(i = 0; i < pattern.length; i++) {\n                totalLength += Math.abs(pattern[i]);\n            }\n\n            dashedLineShader.uniforms = external_THREE_[\"UniformsUtils\"].merge([\n\n                external_THREE_[\"UniformsLib\"][ 'common' ],\n                external_THREE_[\"UniformsLib\"][ 'fog' ],\n\n                {\n                    'pattern': { type: 'fv1', value: pattern },\n                    'patternLength': { type: 'f', value: totalLength }\n                }\n\n            ]);\n\n            dashedLineShader.vertexShader = [\n                'attribute float lineDistance;',\n\n                'varying float vLineDistance;',\n\n                external_THREE_[\"ShaderChunk\"][ 'color_pars_vertex' ],\n\n                'void main() {',\n\n                external_THREE_[\"ShaderChunk\"][ 'color_vertex' ],\n\n                'vLineDistance = lineDistance;',\n\n                'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n                '}'\n            ].join('\\n');\n\n            dashedLineShader.fragmentShader = [\n                'uniform vec3 diffuse;',\n                'uniform float opacity;',\n\n                'uniform float pattern[' + pattern.length + '];',\n                'uniform float patternLength;',\n\n                'varying float vLineDistance;',\n\n                external_THREE_[\"ShaderChunk\"][ 'color_pars_fragment' ],\n                external_THREE_[\"ShaderChunk\"][ 'fog_pars_fragment' ],\n\n                'void main() {',\n\n                'float pos = mod(vLineDistance, patternLength);',\n\n                'for ( int i = 0; i < ' + pattern.length + '; i++ ) {',\n                'pos = pos - abs(pattern[i]);',\n                'if( pos < 0.0 ) {',\n                'if( pattern[i] > 0.0 ) {',\n                'gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );',\n                'break;',\n                '}',\n                'discard;',\n                '}',\n\n                '}',\n\n                external_THREE_[\"ShaderChunk\"][ 'color_fragment' ],\n                external_THREE_[\"ShaderChunk\"][ 'fog_fragment' ],\n\n                '}'\n            ].join('\\n');\n\n            return dashedLineShader;\n        }\n\n        function findExtents(scene) { \n            for(var child of scene.children) {\n                var minX, maxX, minY, maxY;\n                if(child.position) {\n                    minX = Math.min(child.position.x, minX);\n                    minY = Math.min(child.position.y, minY);\n                    maxX = Math.max(child.position.x, maxX);\n                    maxY = Math.max(child.position.y, maxY);\n                }\n            }\n\n            return { min: { x: minX, y: minY }, max: { x: maxX, y: maxY }};\n        }\n\n    }})\n\n/**\n * Viewer class for a dxf object.\n * @param {Object} data - the dxf object generated by dxf-parser\n * @param {Object} parent - the parent element to which we attach the rendering canvas\n * @param {Number} width - width of the rendering canvas in pixels\n * @param {Number} height - height of the rendering canvas in pixels\n * @param {Object} font - a font loaded with THREE.FontLoader \n * @constructor\n */\nfunction Viewer(data, parent, width, height, font) {\n\n    var loader = new DXFLoader();\n\n    // Create THREE meshes\n    var entities = loader.loadEntities(data, font).entities;\n\n    var scene = new external_THREE_[\"Scene\"]();\n\n    // Create scene from dxf object (data)\n    var i, obj, min_x, min_y, min_z, max_x, max_y, max_z;\n    var dims = {\n        min: { x: false, y: false, z: false},\n        max: { x: false, y: false, z: false}\n    };\n    for(i = 0; i < entities.length; i++) {\n        obj = entities[i];\n        if (obj) {\n            var bbox = new external_THREE_[\"Box3\"]().setFromObject(obj);\n            if (bbox.min.x && ((dims.min.x === false) || (dims.min.x > bbox.min.x))) dims.min.x = bbox.min.x;\n            if (bbox.min.y && ((dims.min.y === false) || (dims.min.y > bbox.min.y))) dims.min.y = bbox.min.y;\n            if (bbox.min.z && ((dims.min.z === false) || (dims.min.z > bbox.min.z))) dims.min.z = bbox.min.z;\n            if (bbox.max.x && ((dims.max.x === false) || (dims.max.x < bbox.max.x))) dims.max.x = bbox.max.x;\n            if (bbox.max.y && ((dims.max.y === false) || (dims.max.y < bbox.max.y))) dims.max.y = bbox.max.y;\n            if (bbox.max.z && ((dims.max.z === false) || (dims.max.z < bbox.max.z))) dims.max.z = bbox.max.z;\n            scene.add(obj);\n        }\n        obj = null;\n    }\n\n    width = width || parent.innerWidth;\n    height = height || parent.innerHeight;\n    var aspectRatio = width / height;\n\n    var upperRightCorner = { x: dims.max.x, y: dims.max.y };\n    var lowerLeftCorner = { x: dims.min.x, y: dims.min.y };\n\n    // Figure out the current viewport extents\n    var vp_width = upperRightCorner.x - lowerLeftCorner.x;\n    var vp_height = upperRightCorner.y - lowerLeftCorner.y;\n    var center = center || {\n        x: vp_width / 2 + lowerLeftCorner.x,\n        y: vp_height / 2 + lowerLeftCorner.y\n    };\n\n    // Fit all objects into current ThreeDXF viewer\n    var extentsAspectRatio = Math.abs(vp_width / vp_height);\n    if (aspectRatio > extentsAspectRatio) {\n        vp_width = vp_height * aspectRatio;\n    } else {\n        vp_height = vp_width / aspectRatio;\n    }\n    \n    var viewPort = {\n        bottom: -vp_height / 2,\n        left: -vp_width / 2,\n        top: vp_height / 2,\n        right: vp_width / 2,\n        center: {\n            x: center.x,\n            y: center.y\n        }\n    };\n\n    var camera = new external_THREE_[\"OrthographicCamera\"](viewPort.left, viewPort.right, viewPort.top, viewPort.bottom, 1, 19);\n    camera.position.z = 10;\n    camera.position.x = viewPort.center.x;\n    camera.position.y = viewPort.center.y;\n\n    var renderer = this.renderer = new external_THREE_[\"WebGLRenderer\"]();\n    renderer.setSize(width, height);\n    renderer.setClearColor(0xfffffff, 1);\n\n    parent.appendChild(renderer.domElement);\n    parent.style.display = 'block';\n\n    //TODO: Need to make this an option somehow so others can roll their own controls.\n    var controls = new OrbitControls(camera, parent);\n    controls.target.x = camera.position.x;\n    controls.target.y = camera.position.y;\n    controls.target.z = 0;\n    controls.zoomSpeed = 3;\n\n    //Uncomment this to disable rotation (does not make much sense with 2D drawings).\n    //controls.enableRotate = false;\n\n    this.render = function() { renderer.render(scene, camera) };\n    controls.addEventListener('change', this.render);\n    this.render();\n    controls.update();\n\n    this.resize = function(width, height) {\n        var originalWidth = renderer.domElement.width;\n        var originalHeight = renderer.domElement.height;\n\n        var hscale = width / originalWidth;\n        var vscale = height / originalHeight;\n\n\n        camera.top = (vscale * camera.top);\n        camera.bottom = (vscale * camera.bottom);\n        camera.left = (hscale * camera.left);\n        camera.right = (hscale * camera.right);\n\n//        camera.updateProjectionMatrix();\n\n        renderer.setSize(width, height);\n        renderer.setClearColor(0xfffffff, 1);\n        this.render();\n    };\n}\n\n// Show/Hide helpers from https://plainjs.com/javascript/effects/hide-or-show-an-element-42/\n// get the default display style of an element\nfunction defaultDisplay(tag) {\n    var iframe = document.createElement('iframe');\n    iframe.setAttribute('frameborder', 0);\n    iframe.setAttribute('width', 0);\n    iframe.setAttribute('height', 0);\n    document.documentElement.appendChild(iframe);\n\n    var doc = (iframe.contentWindow || iframe.contentDocument).document;\n\n    // IE support\n    doc.write();\n    doc.close();\n\n    var testEl = doc.createElement(tag);\n    doc.documentElement.appendChild(testEl);\n    var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display\n    iframe.parentNode.removeChild(iframe);\n    return display;\n}\n\n// actual show/hide function used by show() and hide() below\nfunction showHide(el, show) {\n    var value = el.getAttribute('data-olddisplay'),\n    display = el.style.display,\n    computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display;\n\n    if (show) {\n        if (!value && display === 'none') el.style.display = '';\n        if (el.style.display === '' && (computedDisplay === 'none')) value = value || defaultDisplay(el.nodeName);\n    } else {\n        if (display && display !== 'none' || !(computedDisplay == 'none'))\n            el.setAttribute('data-olddisplay', (computedDisplay == 'none') ? display : computedDisplay);\n    }\n    if (!show || el.style.display === 'none' || el.style.display === '')\n        el.style.display = show ? value || '' : 'none';\n}\n\n// helper functions\nfunction show(el) { showHide(el, true); }\nfunction hide(el) { showHide(el); }\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9EeGZBcnJheVNjYW5uZXIuanM/MzJiOSIsIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9BdXRvQ2FkQ29sb3JJbmRleC5qcz81NzAzIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL1BhcnNlSGVscGVycy5qcz8wN2Y2Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzLzNkZmFjZS5qcz9kMDdjIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL2FyYy5qcz9hOTc5Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL2F0dGRlZi5qcz81ZmNlIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL2NpcmNsZS5qcz8xMjg4Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL2RpbWVuc2lvbi5qcz8xN2E1Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL2VsbGlwc2UuanM/OTQ0ZiIsIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9lbnRpdGllcy9pbnNlcnQuanM/ZTlmMyIsIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9lbnRpdGllcy9saW5lLmpzPzgwMWEiLCJ3ZWJwYWNrOi8vVGhyZWVEeGZMb2FkZXIvLi9ub2RlX21vZHVsZXMvZHhmLXBhcnNlci9zcmMvZW50aXRpZXMvbHdwb2x5bGluZS5qcz9lZjk2Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL210ZXh0LmpzPzU5MzkiLCJ3ZWJwYWNrOi8vVGhyZWVEeGZMb2FkZXIvLi9ub2RlX21vZHVsZXMvZHhmLXBhcnNlci9zcmMvZW50aXRpZXMvcG9pbnQuanM/ZTFkNSIsIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9lbnRpdGllcy92ZXJ0ZXguanM/NjRlNSIsIndlYnBhY2s6Ly9UaHJlZUR4ZkxvYWRlci8uL25vZGVfbW9kdWxlcy9keGYtcGFyc2VyL3NyYy9lbnRpdGllcy9wb2x5bGluZS5qcz9jZWY2Iiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2VudGl0aWVzL3NvbGlkLmpzPzRmNzciLCJ3ZWJwYWNrOi8vVGhyZWVEeGZMb2FkZXIvLi9ub2RlX21vZHVsZXMvZHhmLXBhcnNlci9zcmMvZW50aXRpZXMvc3BsaW5lLmpzPzIzOWYiLCJ3ZWJwYWNrOi8vVGhyZWVEeGZMb2FkZXIvLi9ub2RlX21vZHVsZXMvZHhmLXBhcnNlci9zcmMvZW50aXRpZXMvdGV4dC5qcz80OGMzIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL0R4ZlBhcnNlci5qcz80OTcxIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vbm9kZV9tb2R1bGVzL2R4Zi1wYXJzZXIvc3JjL2luZGV4LmpzP2IzN2MiLCJ3ZWJwYWNrOi8vVGhyZWVEeGZMb2FkZXIvLi9zcmMvT3JiaXRDb250cm9scy5qcz9lMjBmIiwid2VicGFjazovL1RocmVlRHhmTG9hZGVyLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFLDJCQUEyQjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7O0FDeFFzRDs7QUFFdkQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1AsUUFBUSxpQkFBb0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDTyxTQUFTLHVCQUFVO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0cwQzs7QUFFM0I7O0FBRWY7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakYwQzs7QUFFM0IsU0FBUyxnQkFBWTs7QUFFcEMsZ0JBQVk7O0FBRVosZ0JBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx1QkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7QUNsQzBDOztBQUUzQixTQUFTLG1CQUFZOztBQUVwQyxtQkFBWTs7QUFFWixtQkFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBa0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyx1QkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7O0FDM0YwQzs7QUFFM0IsU0FBUyxtQkFBWTs7QUFFcEMsbUJBQVk7O0FBRVosbUJBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx1QkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7QUN0QzBDOztBQUUzQixTQUFTLHNCQUFZOztBQUVwQyxzQkFBWTs7QUFFWixzQkFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUFrQjtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLHVCQUFrQjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCLHVCQUFrQjtBQUMvQztBQUNBO0FBQ0Esb0NBQW9DLHVCQUFrQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLHVCQUFrQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLHVCQUFrQjtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLHVCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQkFBbUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7O0FDN0QwQzs7QUFFM0IsU0FBUyxvQkFBWTs7QUFFcEMsb0JBQVk7O0FBRVosb0JBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx1QkFBa0I7QUFDbEQ7QUFDQTtBQUNBLDJDQUEyQyx1QkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBbUM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRTs7O0FDekMwQzs7QUFFM0IsU0FBUyxtQkFBWTs7QUFFcEMsbUJBQVk7O0FBRVosbUJBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBa0I7QUFDOUQ7QUFDQTtBQUNBLGdCQUFnQiwyQkFBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7O0FDdkQwQzs7QUFFM0IsU0FBUyxpQkFBWTs7QUFFcEMsaUJBQVk7O0FBRVosaUJBQVk7QUFDWixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQWtCO0FBQzFEO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQWtCO0FBQ3ZEO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUFtQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7OztBQ2hDMEM7O0FBRTNCLFNBQVMsdUJBQVk7O0FBRXBDLHVCQUFZOztBQUVaLHVCQUFZO0FBQ1osa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7O0FDeEcwQzs7QUFFM0IsU0FBUyxrQkFBWTs7QUFFcEMsa0JBQVk7O0FBRVosa0JBQVk7QUFDWixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7OztBQzdDMEM7O0FBRTNCLFNBQVMsa0JBQVk7O0FBRXBDLGtCQUFZOztBQUVaLGtCQUFZO0FBQ1o7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEU7OztBQ2pDMEM7O0FBRTNCLFNBQVMsbUJBQVk7O0FBRXBDLG1CQUFZOztBQUVaLG1CQUFZO0FBQ1osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUFtQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7OztBQzVEMEM7QUFDTjs7QUFFckIsU0FBUyxxQkFBWTs7QUFFcEMscUJBQVk7O0FBRVoscUJBQVk7QUFDWixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBa0I7QUFDbEU7QUFDQTtBQUNBLEtBQUssMkJBQW1DO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQVk7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUFtQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7Ozs7QUMxRjBDOztBQUUzQixTQUFTLGtCQUFZOztBQUVwQyxrQkFBWTs7QUFFWixrQkFBWTtBQUNaO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQWtCO0FBQ3JEO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQWtCO0FBQ3JEO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQWtCO0FBQ3JEO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQWtCO0FBQ3JEO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQWtCO0FBQzlEO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7O0FDdEMwQzs7QUFFM0IsU0FBUyxtQkFBWTs7QUFFcEMsbUJBQVk7O0FBRVosbUJBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBa0I7QUFDeEQ7QUFDQTtBQUNBLHNDQUFzQyx1QkFBa0I7QUFDeEQ7QUFDQTtBQUNBLG9DQUFvQyx1QkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQWtCO0FBQ3hEO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7O0FDcEUwQzs7QUFFM0IsU0FBUyxpQkFBWTs7QUFFcEMsaUJBQVk7O0FBRVosaUJBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUFrQjtBQUN0RDtBQUNBO0FBQ0Esa0NBQWtDLHVCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM5Q2dEO0FBQ087O0FBRWxCO0FBQ0o7QUFDTTtBQUNBO0FBQ007QUFDSjtBQUNGO0FBQ0o7QUFDWTtBQUNWO0FBQ0E7QUFDTTtBQUNOO0FBQ0U7QUFDSjtBQUNuQzs7QUFFMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQUk7QUFDckMsaUNBQWlDLGdCQUFHO0FBQ3BDLGlDQUFpQyxtQkFBTTtBQUN2QyxpQ0FBaUMsbUJBQU07QUFDdkMsaUNBQWlDLHNCQUFTO0FBQzFDLGlDQUFpQyxvQkFBTztBQUN4QyxpQ0FBaUMsbUJBQU07QUFDdkMsaUNBQWlDLGlCQUFJO0FBQ3JDLGlDQUFpQyx1QkFBVTtBQUMzQyxpQ0FBaUMsa0JBQUs7QUFDdEMsaUNBQWlDLGtCQUFLO0FBQ3RDLGlDQUFpQyxxQkFBUTtBQUN6QyxpQ0FBaUMsa0JBQUs7QUFDdEMsaUNBQWlDLG1CQUFNO0FBQ3ZDLGlDQUFpQyxpQkFBSTtBQUNyQztBQUNBOztBQUVlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUEsZUFBZSxlQUFlO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxrQkFBRztBQUNSO0FBQ0EsS0FBSyxrQkFBRztBQUNSLEtBQUs7QUFDTCxLQUFLLGtCQUFHO0FBQ1I7QUFDQSxLQUFLLGtCQUFHO0FBQ1IsS0FBSztBQUNMLEtBQUssa0JBQUc7QUFDUjtBQUNBLEtBQUssa0JBQUc7QUFDUixLQUFLO0FBQ0wsS0FBSyxrQkFBRztBQUNSO0FBQ0EsS0FBSyxrQkFBRztBQUNSLEtBQUs7QUFDTCxLQUFLLGtCQUFHO0FBQ1IsS0FBSztBQUNMLEtBQUssa0JBQUc7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkUsd0JBQXdCO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksa0JBQUcsZUFBZTtBQUN0QjtBQUNBLElBQUksa0JBQUcsU0FBUztBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFHO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLGtCQUFHLDZCQUE2QjtBQUNyQztBQUNBLEtBQUssa0JBQUcsU0FBUztBQUNqQixLQUFLO0FBQ0wsS0FBSyxrQkFBRztBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsa0JBQUcsa0JBQWtCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0JBQUcsU0FBUztBQUNsQjtBQUNBLE1BQU0sa0JBQUcsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0JBQUcsU0FBUztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsRUFBRSxrQkFBRyxlQUFlO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDOztBQUV6Qzs7QUFFQSxHQUFHLHlDQUF5Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLGNBQWMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEeGZBcnJheVNjYW5uZXJcclxuICpcclxuICogQmFzZWQgb2ZmIHRoZSBBdXRvQ2FkIDIwMTIgRFhGIFJlZmVyZW5jZVxyXG4gKiBodHRwOi8vaW1hZ2VzLmF1dG9kZXNrLmNvbS9hZHNrL2ZpbGVzL2F1dG9jYWRfMjAxMl9wZGZfZHhmLXJlZmVyZW5jZV9lbnUucGRmXHJcbiAqXHJcbiAqIFJlYWRzIHRocm91Z2ggYW4gYXJyYXkgcmVwcmVzZW50aW5nIGxpbmVzIG9mIGEgZHhmIGZpbGUuIFRha2VzIGFuIGFycmF5IGFuZFxyXG4gKiBwcm92aWRlcyBhbiBlYXN5IGludGVyZmFjZSB0byBleHRyYWN0IGdyb3VwIGNvZGUgYW5kIHZhbHVlIHBhaXJzLlxyXG4gKiBAcGFyYW0gZGF0YSAtIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCByZXByZXNlbnRzIGEgbGluZSBpbiB0aGUgZHhmIGZpbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEeGZBcnJheVNjYW5uZXIoZGF0YSkge1xyXG5cdHRoaXMuX3BvaW50ZXIgPSAwO1xyXG5cdHRoaXMuX2RhdGEgPSBkYXRhO1xyXG5cdHRoaXMuX2VvZiA9IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbmV4dCBncm91cCAoY29kZSwgdmFsdWUpIGZyb20gdGhlIGFycmF5LiBBIGdyb3VwIGlzIHR3byBjb25zZWN1dGl2ZSBlbGVtZW50c1xyXG4gKiBpbiB0aGUgYXJyYXkuIFRoZSBmaXJzdCBpcyB0aGUgY29kZSwgdGhlIHNlY29uZCBpcyB0aGUgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHt7Y29kZTogTnVtYmVyfXwqfVxyXG4gKi9cclxuRHhmQXJyYXlTY2FubmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGdyb3VwO1xyXG5cdGlmKCF0aGlzLmhhc05leHQoKSkge1xyXG5cdFx0aWYoIXRoaXMuX2VvZilcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dDogRU9GIGdyb3VwIG5vdCByZWFkIGJlZm9yZSBlbmQgb2YgZmlsZS4gRW5kZWQgb24gY29kZSAnICsgdGhpcy5fZGF0YVt0aGlzLl9wb2ludGVyXSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgXFwnbmV4dFxcJyBhZnRlciBFT0YgZ3JvdXAgaGFzIGJlZW4gcmVhZCcpO1xyXG5cdH1cclxuXHJcblx0Z3JvdXAgPSB7XHJcblx0XHRjb2RlOiBwYXJzZUludCh0aGlzLl9kYXRhW3RoaXMuX3BvaW50ZXJdKVxyXG5cdH07XHJcblxyXG5cdHRoaXMuX3BvaW50ZXIrKztcclxuXHJcblx0Z3JvdXAudmFsdWUgPSBwYXJzZUdyb3VwVmFsdWUoZ3JvdXAuY29kZSwgdGhpcy5fZGF0YVt0aGlzLl9wb2ludGVyXS50cmltKCkpO1xyXG5cdFxyXG5cdHRoaXMuX3BvaW50ZXIrKztcclxuXHJcblx0aWYoZ3JvdXAuY29kZSA9PT0gMCAmJiBncm91cC52YWx1ZSA9PT0gJ0VPRicpIHRoaXMuX2VvZiA9IHRydWU7XHJcblxyXG5cdHRoaXMubGFzdFJlYWRHcm91cCA9IGdyb3VwO1xyXG5cclxuXHRyZXR1cm4gZ3JvdXA7XHJcbn07XHJcblxyXG5EeGZBcnJheVNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuXHRpZighdGhpcy5oYXNOZXh0KCkpIHtcclxuXHRcdGlmKCF0aGlzLl9lb2YpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQ6IEVPRiBncm91cCBub3QgcmVhZCBiZWZvcmUgZW5kIG9mIGZpbGUuIEVuZGVkIG9uIGNvZGUgJyArIHRoaXMuX2RhdGFbdGhpcy5fcG9pbnRlcl0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIFxcJ25leHRcXCcgYWZ0ZXIgRU9GIGdyb3VwIGhhcyBiZWVuIHJlYWQnKTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGdyb3VwID0ge1xyXG5cdFx0Y29kZTogcGFyc2VJbnQodGhpcy5fZGF0YVt0aGlzLl9wb2ludGVyXSlcclxuXHR9O1xyXG5cclxuXHRncm91cC52YWx1ZSA9IHBhcnNlR3JvdXBWYWx1ZShncm91cC5jb2RlLCB0aGlzLl9kYXRhW3RoaXMuX3BvaW50ZXIgKyAxXS50cmltKCkpO1xyXG5cclxuXHRyZXR1cm4gZ3JvdXA7XHJcbn07XHJcblxyXG5cclxuRHhmQXJyYXlTY2FubmVyLnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbihudW1iZXJPZkdyb3Vwcykge1xyXG5cdG51bWJlck9mR3JvdXBzID0gbnVtYmVyT2ZHcm91cHMgfHwgMTtcclxuXHR0aGlzLl9wb2ludGVyID0gdGhpcy5fcG9pbnRlciAtIG51bWJlck9mR3JvdXBzICogMjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW5vdGhlciBjb2RlL3ZhbHVlIHBhaXIgKDIgZWxlbWVudHMgaW4gdGhlIGFycmF5KS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5EeGZBcnJheVNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcclxuXHQvLyBDaGVjayBpZiB3ZSBoYXZlIHJlYWQgRU9GIGdyb3VwIGNvZGVcclxuXHRpZih0aGlzLl9lb2YpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gV2UgbmVlZCB0byBiZSBzdXJlIHRoZXJlIGFyZSB0d28gbGluZXMgYXZhaWxhYmxlXHJcblx0aWYodGhpcy5fcG9pbnRlciA+IHRoaXMuX2RhdGEubGVuZ3RoIC0gMikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNjYW5uZXIgaXMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5EeGZBcnJheVNjYW5uZXIucHJvdG90eXBlLmlzRU9GID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX2VvZjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIHZhbHVlIHRvIGl0cyBwcm9wZXIgdHlwZS5cclxuICogU2VlIHBhZ2VzIDMgLSAxMCBvZiB0aGUgQXV0b0NhZCBEWEYgMjAxMiByZWZlcmVuY2UgZ2l2ZW4gYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGVcclxuICpcclxuICogQHBhcmFtIGNvZGVcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VHcm91cFZhbHVlKGNvZGUsIHZhbHVlKSB7XHJcblx0aWYoY29kZSA8PSA5KSByZXR1cm4gdmFsdWU7XHJcblx0aWYoY29kZSA+PSAxMCAmJiBjb2RlIDw9IDU5KSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcblx0aWYoY29kZSA+PSA2MCAmJiBjb2RlIDw9IDk5KSByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gMTAwICYmIGNvZGUgPD0gMTA5KSByZXR1cm4gdmFsdWU7XHJcblx0aWYoY29kZSA+PSAxMTAgJiYgY29kZSA8PSAxNDkpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcclxuXHRpZihjb2RlID49IDE2MCAmJiBjb2RlIDw9IDE3OSkgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcclxuXHRpZihjb2RlID49IDIxMCAmJiBjb2RlIDw9IDIzOSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gMjcwICYmIGNvZGUgPD0gMjg5KSByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gMjkwICYmIGNvZGUgPD0gMjk5KSByZXR1cm4gcGFyc2VCb29sZWFuKHZhbHVlKTtcclxuXHRpZihjb2RlID49IDMwMCAmJiBjb2RlIDw9IDM2OSkgcmV0dXJuIHZhbHVlO1xyXG5cdGlmKGNvZGUgPj0gMzcwICYmIGNvZGUgPD0gMzg5KSByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gMzkwICYmIGNvZGUgPD0gMzk5KSByZXR1cm4gdmFsdWU7XHJcblx0aWYoY29kZSA+PSA0MDAgJiYgY29kZSA8PSA0MDkpIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XHJcblx0aWYoY29kZSA+PSA0MTAgJiYgY29kZSA8PSA0MTkpIHJldHVybiB2YWx1ZTtcclxuXHRpZihjb2RlID49IDQyMCAmJiBjb2RlIDw9IDQyOSkgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcclxuXHRpZihjb2RlID49IDQzMCAmJiBjb2RlIDw9IDQzOSkgcmV0dXJuIHZhbHVlO1xyXG5cdGlmKGNvZGUgPj0gNDQwICYmIGNvZGUgPD0gNDU5KSByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gNDYwICYmIGNvZGUgPD0gNDY5KSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcblx0aWYoY29kZSA+PSA0NzAgJiYgY29kZSA8PSA0ODEpIHJldHVybiB2YWx1ZTtcclxuXHRpZihjb2RlID09PSA5OTkpIHJldHVybiB2YWx1ZTtcclxuXHRpZihjb2RlID49IDEwMDAgJiYgY29kZSA8PSAxMDA5KSByZXR1cm4gdmFsdWU7XHJcblx0aWYoY29kZSA+PSAxMDEwICYmIGNvZGUgPD0gMTA1OSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xyXG5cdGlmKGNvZGUgPj0gMTA2MCAmJiBjb2RlIDw9IDEwNzEpIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XHJcblxyXG5cdGNvbnNvbGUubG9nKCdXQVJOSU5HOiBHcm91cCBjb2RlIGRvZXMgbm90IGhhdmUgYSBkZWZpbmVkIHR5cGU6ICVqJywgeyBjb2RlOiBjb2RlLCB2YWx1ZTogdmFsdWUgfSk7XHJcblx0cmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBib29sZWFuIGFjY29yZGluZyB0byBhIDEgb3IgMCB2YWx1ZVxyXG4gKiBAcGFyYW0gc3RyXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VCb29sZWFuKHN0cikge1xyXG5cdGlmKHN0ciA9PT0gJzAnKSByZXR1cm4gZmFsc2U7XHJcblx0aWYoc3RyID09PSAnMScpIHJldHVybiB0cnVlO1xyXG5cdHRocm93IFR5cGVFcnJvcignU3RyaW5nIFxcJycgKyBzdHIgKyAnXFwnIGNhbm5vdCBiZSBjYXN0IHRvIEJvb2xlYW4gdHlwZScpO1xyXG59IiwiLyoqXHJcbiAqIEF1dG9DYWQgZmlsZXMgc29tZXRpbWVzIHVzZSBhbiBpbmRleGVkIGNvbG9yIHZhbHVlIGJldHdlZW4gMSBhbmQgMjU1IGluY2x1c2l2ZS5cclxuICogRWFjaCB2YWx1ZSBjb3JyZXNwb25kcyB0byBhIGNvbG9yLiBpbmRleCAxIGlzIHJlZCwgdGhhdCBpcyAxNjcxMTY4MCBvciAweEZGMDAwMC5cclxuICogaW5kZXggMCBhbmQgMjU2LCB3aGlsZSBpbmNsdWRlZCBpbiB0aGlzIGFycmF5LCBhcmUgYWN0dWFsbHkgcmVzZXJ2ZWQgZm9yIGluaGVyaXRhbmNlXHJcbiAqIHZhbHVlcyBpbiBBdXRvQ2FkIHNvIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGZvciBpbmRleCBjb2xvciBsb29rdXBzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuIDAsXHJcbiAxNjcxMTY4MCxcclxuIDE2Nzc2OTYwLFxyXG4gNjUyODAsXHJcbiA2NTUzNSxcclxuIDI1NSxcclxuIDE2NzExOTM1LFxyXG4gMTY3NzcyMTUsXHJcbiA4NDIxNTA0LFxyXG4gMTI2MzIyNTYsXHJcbiAxNjcxMTY4MCxcclxuIDE2NzQ0MzE5LFxyXG4gMTMzNjkzNDQsXHJcbiAxMzM5NTU1OCxcclxuIDEwMDI3MDA4LFxyXG4gMTAwNDY1NDAsXHJcbiA4MzIzMDcyLFxyXG4gODMzOTI2MyxcclxuIDQ5ODA3MzYsXHJcbiA0OTkwNTAyLFxyXG4gMTY3Mjc4MDgsXHJcbiAxNjc1MjUxMSxcclxuIDEzMzgyNDAwLFxyXG4gMTM0MDE5NTgsXHJcbiAxMDAzNjczNixcclxuIDEwMDUxNDA0LFxyXG4gODMzMTAwOCxcclxuIDgzNDMzNTksXHJcbiA0OTg1NjAwLFxyXG4gNDk5MjgwNixcclxuIDE2NzQ0MTkyLFxyXG4gMTY3NjA3MDMsXHJcbiAxMzM5NTQ1NixcclxuIDEzNDA4NjE0LFxyXG4gMTAwNDY0NjQsXHJcbiAxMDA1NjI2OCxcclxuIDgzMzkyMDAsXHJcbiA4MzQ3NDU1LFxyXG4gNDk5MDQ2NCxcclxuIDQ5OTUzNjYsXHJcbiAxNjc2MDU3NixcclxuIDE2NzY4ODk1LFxyXG4gMTM0MDg1MTIsXHJcbiAxMzQxNTAxNCxcclxuIDEwMDU2MTkyLFxyXG4gMTAwNjExMzIsXHJcbiA4MzQ3MzkyLFxyXG4gODM1MTU1MSxcclxuIDQ5OTUzMjgsXHJcbiA0OTk3NjcwLFxyXG4gMTY3NzY5NjAsXHJcbiAxNjc3NzA4NyxcclxuIDEzNDIxNTY4LFxyXG4gMTM0MjE2NzAsXHJcbiAxMDAwMDM4NCxcclxuIDEwMDAwNDYwLFxyXG4gODM1NTU4NCxcclxuIDgzNTU2NDcsXHJcbiA1MDAwMTkyLFxyXG4gNTAwMDIzMCxcclxuIDEyNTgyNjU2LFxyXG4gMTQ2Nzk5MzUsXHJcbiAxMDA3OTIzMixcclxuIDExNzE3NzM0LFxyXG4gNzUxMDAxNixcclxuIDg3NTUyNzYsXHJcbiA2MjU4NDMyLFxyXG4gNzMwNzA3MSxcclxuIDM3NTUwMDgsXHJcbiA0MzQ0ODcwLFxyXG4gODM4ODM1MixcclxuIDEyNTgyNzgzLFxyXG4gNjczNjg5NixcclxuIDEwMDc5MzM0LFxyXG4gNTAxOTY0OCxcclxuIDc1MTAwOTIsXHJcbiA0MTYxMjgwLFxyXG4gNjI1ODQ5NSxcclxuIDI1MDk4MjQsXHJcbiAzNzU1MDQ2LFxyXG4gNDE5NDA0OCxcclxuIDEwNDg1NjMxLFxyXG4gMzM5NDU2MCxcclxuIDgzNzUzOTgsXHJcbiAyNTI5MjgwLFxyXG4gNjI2NDkwOCxcclxuIDIwNjQxMjgsXHJcbiA1MjA5OTE5LFxyXG4gMTI2NDY0MCxcclxuIDMwOTk2ODYsXHJcbiA2NTI4MCxcclxuIDgzODg0NzksXHJcbiA1MjIyNCxcclxuIDY3MzY5OTgsXHJcbiAzODkxMixcclxuIDUwMTk3MjQsXHJcbiAzMjUxMixcclxuIDQxNjEzNDMsXHJcbiAxOTQ1NixcclxuIDI1MDk4NjIsXHJcbiA2NTM0MyxcclxuIDgzODg1MTEsXHJcbiA1MjI3NSxcclxuIDY3MzcwMjMsXHJcbiAzODk1MCxcclxuIDUwMTk3NDMsXHJcbiAzMjU0MyxcclxuIDQxNjEzNTksXHJcbiAxOTQ3NSxcclxuIDI1MDk4NzEsXHJcbiA2NTQwNyxcclxuIDgzODg1NDMsXHJcbiA1MjMyNixcclxuIDY3MzcwNDksXHJcbiAzODk4OCxcclxuIDUwMTk3NjIsXHJcbiAzMjU3NSxcclxuIDQxNjEzNzUsXHJcbiAxOTQ5NCxcclxuIDI1MDk4ODEsXHJcbiA2NTQ3MSxcclxuIDgzODg1NzUsXHJcbiA1MjM3NyxcclxuIDY3MzcwNzQsXHJcbiAzOTAyNixcclxuIDUwMTk3ODEsXHJcbiAzMjYwNyxcclxuIDQxNjEzOTEsXHJcbiAxOTUxMyxcclxuIDI1MDk4OTAsXHJcbiA2NTUzNSxcclxuIDgzODg2MDcsXHJcbiA1MjQyOCxcclxuIDY3MzcxMDAsXHJcbiAzOTA2NCxcclxuIDUwMTk4MDAsXHJcbiAzMjYzOSxcclxuIDQxNjE0MDcsXHJcbiAxOTUzMixcclxuIDI1MDk5MDAsXHJcbiA0OTE1MSxcclxuIDgzODA0MTUsXHJcbiAzOTM3MixcclxuIDY3MzA0NDQsXHJcbiAyOTMzNixcclxuIDUwMTQ5MzYsXHJcbiAyNDQ0NyxcclxuIDQxNTczMTEsXHJcbiAxNDY2OCxcclxuIDI1MDczNDAsXHJcbiAzMjc2NyxcclxuIDgzNzIyMjMsXHJcbiAyNjMxNixcclxuIDY3MjQwNDQsXHJcbiAxOTYwOCxcclxuIDUwMTAwNzIsXHJcbiAxNjI1NSxcclxuIDQxNTMyMTUsXHJcbiA5ODA0LFxyXG4gMjUwNTAzNixcclxuIDE2MzgzLFxyXG4gODM2NDAzMSxcclxuIDEzMjYwLFxyXG4gNjcxNzM4OCxcclxuIDk4ODAsXHJcbiA1MDA1MjA4LFxyXG4gODA2MyxcclxuIDQxNDkxMTksXHJcbiA0OTQwLFxyXG4gMjUwMjQ3NixcclxuIDI1NSxcclxuIDgzNTU4MzksXHJcbiAyMDQsXHJcbiA2NzEwOTg4LFxyXG4gMTUyLFxyXG4gNTAwMDM0NCxcclxuIDEyNyxcclxuIDQxNDUwMjMsXHJcbiA3NixcclxuIDI1MDAxNzIsXHJcbiA0MTI5MDIzLFxyXG4gMTA0NTI5OTEsXHJcbiAzMzQyNTQwLFxyXG4gODM0OTM4OCxcclxuIDI0OTA1MjAsXHJcbiA2MjQ1NTI4LFxyXG4gMjAzMTc0MyxcclxuIDUxOTM1OTksXHJcbiAxMjQ1MjYwLFxyXG4gMzA4OTk5NixcclxuIDgzMjMzMjcsXHJcbiAxMjU1MDE0MyxcclxuIDY2ODQ4NzYsXHJcbiAxMDA1MzMyNCxcclxuIDQ5ODA4ODgsXHJcbiA3NDkwNzEyLFxyXG4gNDEyODg5NSxcclxuIDYyNDIxNzUsXHJcbiAyNDkwNDQ0LFxyXG4gMzc0NTM1NixcclxuIDEyNTE3NjMxLFxyXG4gMTQ2NDcyOTUsXHJcbiAxMDAyNzIxMixcclxuIDExNjkxNzI0LFxyXG4gNzQ3MTI1NixcclxuIDg3MzU4OTYsXHJcbiA2MjI2MDQ3LFxyXG4gNzI5MDc1MSxcclxuIDM3MzU2MjgsXHJcbiA0MzM1MTgwLFxyXG4gMTY3MTE5MzUsXHJcbiAxNjc0NDQ0NyxcclxuIDEzMzY5NTQ4LFxyXG4gMTMzOTU2NjAsXHJcbiA5OTYxNjI0LFxyXG4gOTk4MTA4MCxcclxuIDgzMjMxOTksXHJcbiA4MzM5MzI3LFxyXG4gNDk4MDgxMixcclxuIDQ5OTA1NDAsXHJcbiAxNjcxMTg3MSxcclxuIDE2NzQ0NDE1LFxyXG4gMTMzNjk0OTcsXHJcbiAxMzM5NTYzNCxcclxuIDk5NjE1ODYsXHJcbiA5OTgxMDYxLFxyXG4gODMyMzE2NyxcclxuIDgzMzkzMTEsXHJcbiA0OTgwNzkzLFxyXG4gNDk5MDUzMCxcclxuIDE2NzExODA3LFxyXG4gMTY3NDQzODMsXHJcbiAxMzM2OTQ0NixcclxuIDEzMzk1NjA5LFxyXG4gOTk2MTU0OCxcclxuIDk5ODEwNDIsXHJcbiA4MzIzMTM1LFxyXG4gODMzOTI5NSxcclxuIDQ5ODA3NzQsXHJcbiA0OTkwNTIxLFxyXG4gMTY3MTE3NDMsXHJcbiAxNjc0NDM1MSxcclxuIDEzMzY5Mzk1LFxyXG4gMTMzOTU1ODMsXHJcbiA5OTYxNTEwLFxyXG4gOTk4MTAyMyxcclxuIDgzMjMxMDMsXHJcbiA4MzM5Mjc5LFxyXG4gNDk4MDc1NSxcclxuIDQ5OTA1MTEsXHJcbiAzMzU1NDQzLFxyXG4gNTk4NzE2MyxcclxuIDg2ODQ2NzYsXHJcbiAxMTM4MjE4OSxcclxuIDE0MDc5NzAyLFxyXG4gMTY3NzcyMTVcclxuXTsiLCJpbXBvcnQgQVVUT19DQURfQ09MT1JfSU5ERVggZnJvbSAnLi9BdXRvQ2FkQ29sb3JJbmRleCc7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdHJ1ZWNvbG9yIHZhbHVlIG9mIHRoZSBnaXZlbiBBdXRvQ2FkIGNvbG9yIGluZGV4IHZhbHVlXHJcbiAqIEByZXR1cm4ge051bWJlcn0gdHJ1ZWNvbG9yIHZhbHVlIGFzIGEgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNhZENvbG9yKGluZGV4KSB7XHJcblx0cmV0dXJuIEFVVE9fQ0FEX0NPTE9SX0lOREVYW2luZGV4XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgMkQgb3IgM0QgY29vcmRpbmF0ZSwgdmVjdG9yLCBvciBwb2ludC4gV2hlbiBjb21wbGV0ZSxcclxuICogdGhlIHNjYW5uZXIgcmVtYWlucyBvbiB0aGUgbGFzdCBncm91cCBvZiB0aGUgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHsqfSBzY2FubmVyIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUG9pbnQoc2Nhbm5lcikge1xyXG4gICAgdmFyIHBvaW50ID0ge307XHJcblxyXG4gICAgLy8gUmVyZWFkIGdyb3VwIGZvciB0aGUgZmlyc3QgY29vcmRpbmF0ZVxyXG4gICAgc2Nhbm5lci5yZXdpbmQoKTtcclxuICAgIHZhciBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblxyXG4gICAgdmFyIGNvZGUgPSBjdXJyLmNvZGU7XHJcbiAgICBwb2ludC54ID0gY3Vyci52YWx1ZTtcclxuXHJcbiAgICBjb2RlICs9IDEwO1xyXG4gICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgaWYoY3Vyci5jb2RlICE9IGNvZGUpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBjb2RlIGZvciBwb2ludCB2YWx1ZSB0byBiZSAnICsgY29kZSArXHJcbiAgICAgICAgJyBidXQgZ290ICcgKyBjdXJyLmNvZGUgKyAnLicpO1xyXG4gICAgcG9pbnQueSA9IGN1cnIudmFsdWU7XHJcblxyXG4gICAgY29kZSArPSAxMDtcclxuICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIGlmKGN1cnIuY29kZSAhPSBjb2RlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIE9ubHkgdGhlIHggYW5kIHkgYXJlIHNwZWNpZmllZC4gRG9uJ3QgcmVhZCB6LlxyXG4gICAgICAgIHNjYW5uZXIucmV3aW5kKCk7IC8vIExldCB0aGUgY2FsbGluZyBjb2RlIGFkdmFuY2Ugb2ZmIHRoZSBwb2ludFxyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuICAgIHBvaW50LnogPSBjdXJyLnZhbHVlO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGFyc2UgY29kZXMgY29tbW9uIHRvIGFsbCBlbnRpdGllcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cFxyXG4gKiB3YXMgaGFuZGxlZCBieSB0aGlzIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0geyp9IGVudGl0eSAtIHRoZSBlbnRpdHkgY3VycmVudGx5IGJlaW5nIHBhcnNlZCBcclxuICogQHBhcmFtIHsqfSBjdXJyIC0gdGhlIGN1cnJlbnQgZ3JvdXAgYmVpbmcgcGFyc2VkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycikge1xyXG4gICAgc3dpdGNoKGN1cnIuY29kZSkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgZW50aXR5LnR5cGUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIGVudGl0eS5oYW5kbGUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgIGVudGl0eS5saW5lVHlwZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODogLy8gTGF5ZXIgbmFtZVxyXG4gICAgICAgICAgICBlbnRpdHkubGF5ZXIgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ4OlxyXG4gICAgICAgICAgICBlbnRpdHkubGluZVR5cGVTY2FsZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNjA6XHJcbiAgICAgICAgICAgIGVudGl0eS52aXNpYmxlID0gY3Vyci52YWx1ZSA9PT0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA2MjogLy8gQWNhZCBJbmRleCBDb2xvci4gMCBpbmhlcml0cyBCeUJsb2NrLiAyNTYgaW5oZXJpdHMgQnlMYXllci4gRGVmYXVsdCBpcyBieWxheWVyXHJcbiAgICAgICAgICAgIGVudGl0eS5jb2xvckluZGV4ID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgZW50aXR5LmNvbG9yID0gZ2V0QWNhZENvbG9yKE1hdGguYWJzKGN1cnIudmFsdWUpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA2NzpcclxuICAgICAgICAgICAgZW50aXR5LmluUGFwZXJTcGFjZSA9IGN1cnIudmFsdWUgIT09IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTAwOlxyXG4gICAgICAgICAgICAvL2lnbm9yZVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDMzMDpcclxuICAgICAgICAgICAgZW50aXR5Lm93bmVySGFuZGxlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzNDc6XHJcbiAgICAgICAgICAgIGVudGl0eS5tYXRlcmlhbE9iamVjdEhhbmRsZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzcwOlxyXG4gICAgICAgICAgICAvL0Zyb20gaHR0cHM6Ly93d3cud291dHdhcmUuY29tL0ZvcnVtL1RvcGljLzk1NS9saW5ld2VpZ2h0P3JldHVyblVybD0lMkZGb3J1bSUyRlVzZXJQb3N0cyUzRnVzZXJJZCUzRDQ3ODI2MjMxOVxyXG4gICAgICAgICAgICAvLyBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyAxMDB0aCBvZiBtbSwgbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XHJcbiAgICAgICAgICAgIC8vIDAsIDUsIDksIDEzLCAxNSwgMTgsIDIwLCAyNSwgMzAsIDM1LCA0MCwgNTAsIDUzLCA2MCwgNzAsIDgwLCA5MCwgMTAwLCAxMDYsIDEyMCwgMTQwLCAxNTgsIDIwMCwgMjExLlxyXG4gICAgICAgICAgICAvLyAtMyA9IFNUQU5EQVJELCAtMiA9IEJZTEFZRVIsIC0xID0gQllCTE9DS1xyXG4gICAgICAgICAgICBlbnRpdHkubGluZXdlaWdodCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDIwOiAvLyBUcnVlQ29sb3IgQ29sb3JcclxuICAgICAgICAgICAgZW50aXR5LmNvbG9yID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMDAwOiBcclxuICAgICAgICAgICAgZW50aXR5LmV4dGVuZGVkRGF0YSA9IGVudGl0eS5leHRlbmRlZERhdGEgfHwge307XHJcbiAgICAgICAgICAgIGVudGl0eS5leHRlbmRlZERhdGEuY3VzdG9tU3RyaW5ncyA9IGVudGl0eS5leHRlbmRlZERhdGEuY3VzdG9tU3RyaW5ncyB8fCBbXTsgXHJcbiAgICAgICAgICAgIGVudGl0eS5leHRlbmRlZERhdGEuY3VzdG9tU3RyaW5ncy5wdXNoKGN1cnIudmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEwMDE6IFxyXG4gICAgICAgICAgICBlbnRpdHkuZXh0ZW5kZWREYXRhID0gZW50aXR5LmV4dGVuZGVkRGF0YSB8fCB7fTtcclxuICAgICAgICAgICAgZW50aXR5LmV4dGVuZGVkRGF0YS5hcHBsaWNhdGlvbk5hbWUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuIiwiXHJcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vUGFyc2VIZWxwZXJzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRW50aXR5UGFyc2VyKCkge31cclxuXHJcbkVudGl0eVBhcnNlci5Gb3JFbnRpdHlOYW1lID0gJzNERkFDRSc7XHJcblxyXG5FbnRpdHlQYXJzZXIucHJvdG90eXBlLnBhcnNlRW50aXR5ID0gZnVuY3Rpb24oc2Nhbm5lciwgY3Vycikge1xyXG5cclxuICAgIHZhciBlbnRpdHkgPSB7IHR5cGU6IGN1cnIudmFsdWUsIHZlcnRpY2VzOiBbXSB9O1xyXG4gICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgd2hpbGUgKGN1cnIgIT09ICdFT0YnKSB7XHJcbiAgICAgICAgaWYgKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgc3dpdGNoIChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSA3MDogLy8gMSA9IENsb3NlZCBzaGFwZSwgMTI4ID0gcGxpbmVnZW4/LCAwID0gZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnNoYXBlID0gKChjdXJyLnZhbHVlICYgMSkgPT09IDEpO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Lmhhc0NvbnRpbnVvdXNMaW5ldHlwZVBhdHRlcm4gPSAoKGN1cnIudmFsdWUgJiAxMjgpID09PSAxMjgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IC8vIFggY29vcmRpbmF0ZSBvZiBwb2ludFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnZlcnRpY2VzID0gcGFyc2UzZEZhY2VWZXJ0aWNlcyhzY2FubmVyLCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSBzY2FubmVyLmxhc3RSZWFkR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlM2RGYWNlVmVydGljZXMoc2Nhbm5lciwgY3Vycikge1xyXG4gICAgdmFyIHZlcnRpY2VzID0gW10sXHJcbiAgICAgICAgaTtcclxuICAgIHZhciB2ZXJ0ZXhJc1N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIHZhciB2ZXJ0ZXhJc0ZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICB2YXIgdmVydGljZXNQZXIzZEZhY2UgPSA0OyAvLyB0aGVyZSBjYW4gYmUgdXAgdG8gZm91ciB2ZXJ0aWNlcyBwZXIgZmFjZSwgYWx0aG91Z2ggMyBpcyBtb3N0IHVzZWQgZm9yIFRJTlxyXG4gICAgXHJcbiAgICBmb3IgKGkgPSAwOyBpIDw9IHZlcnRpY2VzUGVyM2RGYWNlOyBpKyspIHtcclxuICAgICAgICB2YXIgdmVydGV4ID0ge307XHJcbiAgICAgICAgd2hpbGUgKGN1cnIgIT09ICdFT0YnKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyLmNvZGUgPT09IDAgfHwgdmVydGV4SXNGaW5pc2hlZCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnIuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gWDBcclxuICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIFgxXHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBYMlxyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzogLy8gWDNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4SXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleElzRmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4LnggPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleElzU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIwOiAvLyBZXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjM6XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4LnkgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gWlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleC56ID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBlbnRpdHkgY29kZXMgYWZ0ZXIgdGhlIHZlcnRpY2VzLiAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU28gaWYgY29kZSBpcyBub3QgYWNjb3VudGVkIGZvciByZXR1cm4gdG8gZW50aXR5IHBhcnNlciB3aGVyZSBpdCBtaWdodCBiZSBhY2NvdW50ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9jb21wLmNhZC5hdXRvY2FkLzlnbjhzNU9fdzZFXHJcbiAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xyXG4gICAgICAgIHZlcnRleElzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZlcnRleElzRmluaXNoZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHNjYW5uZXIucmV3aW5kKCk7XHJcbiAgICByZXR1cm4gdmVydGljZXM7XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uL1BhcnNlSGVscGVycydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVudGl0eVBhcnNlcigpIHt9XHJcblxyXG5FbnRpdHlQYXJzZXIuRm9yRW50aXR5TmFtZSA9ICdBUkMnO1xyXG5cclxuRW50aXR5UGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uKHNjYW5uZXIsIGN1cnIpIHtcclxuICAgIHZhciBlbnRpdHksIGVuZEFuZ2xlO1xyXG4gICAgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxMDogLy8gWCBjb29yZGluYXRlIG9mIHBvaW50XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuY2VudGVyID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnJhZGl1cyA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1MDogLy8gc3RhcnQgYW5nbGVcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zdGFydEFuZ2xlID0gTWF0aC5QSSAvIDE4MCAqIGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1MTogLy8gZW5kIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZW5kQW5nbGUgPSBNYXRoLlBJIC8gMTgwICogY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5hbmdsZUxlbmd0aCA9IGVudGl0eS5lbmRBbmdsZSAtIGVudGl0eS5zdGFydEFuZ2xlOyAvLyBhbmdsZUxlbmd0aCBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogLy8gaWdub3JlZCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgIGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnQVRUREVGJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5ID0ge1xyXG4gICAgICAgIHR5cGU6IGN1cnIudmFsdWUsXHJcbiAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgdGV4dFN0eWxlOiAnU1RBTkRBUkQnXHJcbiAgICAgfTtcclxuICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIHdoaWxlIChjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmIChjdXJyLmNvZGUgPT09IDApIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRleHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGVudGl0eS50YWcgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5wcm9tcHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIGVudGl0eS50ZXh0U3R5bGUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IC8vIFggY29vcmRpbmF0ZSBvZiAnZmlyc3QgYWxpZ25tZW50IHBvaW50J1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnN0YXJ0UG9pbnQgPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMTogLy8gWCBjb29yZGluYXRlIG9mICdzZWNvbmQgYWxpZ25tZW50IHBvaW50J1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmVuZFBvaW50ID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudGhpY2tuZXNzID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQwOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRleHRIZWlnaHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc2NhbGUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucm90YXRpb24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkub2JsaXF1ZUFuZ2xlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDcwOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmludmlzaWJsZSA9ICEhKGN1cnIudmFsdWUgJiAweDAxKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5jb25zdGFudCA9ICEhKGN1cnIudmFsdWUgJiAweDAyKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS52ZXJpZmljYXRpb25SZXF1aXJlZCA9ICEhKGN1cnIudmFsdWUgJiAweDA0KTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5wcmVzZXQgPSAhIShjdXJyLnZhbHVlICYgMHgwOCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MTpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5iYWNrd2FyZHMgPSAhIShjdXJyLnZhbHVlICYgMHgwMik7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkubWlycm9yZWQgPSAhIShjdXJyLnZhbHVlICYgMHgwNCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MjpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGVudW0gdmFsdWVzP1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Lmhvcml6b250YWxKdXN0aWZpY2F0aW9uID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDczOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmZpZWxkTGVuZ3RoID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDc0OlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZW51bSB2YWx1ZXM/XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudmVydGljYWxKdXN0aWZpY2F0aW9uID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEwMDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIxMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25YID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIyMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25ZID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIzMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25aID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaGVscGVycy5jaGVja0NvbW1vbkVudGl0eVByb3BlcnRpZXMoZW50aXR5LCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnQ0lSQ0xFJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5LCBlbmRBbmdsZTtcclxuICAgIGVudGl0eSA9IHsgdHlwZTogY3Vyci52YWx1ZSB9O1xyXG4gICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgd2hpbGUoY3VyciAhPT0gJ0VPRicpIHtcclxuICAgICAgICBpZihjdXJyLmNvZGUgPT09IDApIGJyZWFrO1xyXG5cclxuICAgICAgICBzd2l0Y2goY3Vyci5jb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IC8vIFggY29vcmRpbmF0ZSBvZiBwb2ludFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmNlbnRlciA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQwOiAvLyByYWRpdXNcclxuICAgICAgICAgICAgICAgIGVudGl0eS5yYWRpdXMgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTA6IC8vIHN0YXJ0IGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc3RhcnRBbmdsZSA9IE1hdGguUEkgLyAxODAgKiBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTE6IC8vIGVuZCBhbmdsZVxyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBNYXRoLlBJIC8gMTgwICogY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmKGVuZEFuZ2xlIDwgZW50aXR5LnN0YXJ0QW5nbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5LmFuZ2xlTGVuZ3RoID0gZW5kQW5nbGUgKyAyICogTWF0aC5QSSAtIGVudGl0eS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5hbmdsZUxlbmd0aCA9IGVuZEFuZ2xlIC0gZW50aXR5LnN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZW5kQW5nbGUgPSBlbmRBbmdsZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiAvLyBpZ25vcmVkIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgaGVscGVycy5jaGVja0NvbW1vbkVudGl0eVByb3BlcnRpZXMoZW50aXR5LCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50aXR5O1xyXG59OyIsIlxyXG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uL1BhcnNlSGVscGVycydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVudGl0eVBhcnNlcigpIHt9XHJcblxyXG5FbnRpdHlQYXJzZXIuRm9yRW50aXR5TmFtZSA9ICdESU1FTlNJT04nO1xyXG5cclxuRW50aXR5UGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uKHNjYW5uZXIsIGN1cnIpIHtcclxuICAgIHZhciBlbnRpdHk7XHJcblx0XHRlbnRpdHkgPSB7IHR5cGU6IGN1cnIudmFsdWUgfTtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHdoaWxlKGN1cnIgIT09ICdFT0YnKSB7XHJcblx0XHRcdGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG5cdFx0XHRzd2l0Y2goY3Vyci5jb2RlKSB7XHJcblx0XHRcdFx0Y2FzZSAyOiAvLyBSZWZlcmVuY2VkIGJsb2NrIG5hbWVcclxuXHRcdFx0XHRcdGVudGl0eS5ibG9jayA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDEwOiAvLyBYIGNvb3JkaW5hdGUgb2YgJ2ZpcnN0IGFsaWdubWVudCBwb2ludCdcclxuXHRcdFx0XHRcdGVudGl0eS5hbmNob3JQb2ludCA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTE6XHJcblx0XHRcdFx0XHRlbnRpdHkubWlkZGxlT2ZUZXh0ID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMjogLy8gSW5zZXJ0aW9uIHBvaW50IGZvciBjbG9uZXMgb2YgYSBkaW1lbnNpb25cclxuXHRcdFx0XHRcdGVudGl0eS5pbnNlcnRpb25Qb2ludCA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTM6IC8vIERlZmluaXRpb24gcG9pbnQgZm9yIGxpbmVhciBhbmQgYW5ndWxhciBkaW1lbnNpb25zIFxyXG5cdFx0XHRcdFx0ZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MSA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTQ6IC8vIERlZmluaXRpb24gcG9pbnQgZm9yIGxpbmVhciBhbmQgYW5ndWxhciBkaW1lbnNpb25zIFxyXG5cdFx0XHRcdFx0ZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MiA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTU6IC8vIERlZmluaXRpb24gcG9pbnQgZm9yIGRpYW1ldGVyLCByYWRpdXMsIGFuZCBhbmd1bGFyIGRpbWVuc2lvbnNcclxuXHRcdFx0XHRcdGVudGl0eS5kaWFtZXRlck9yUmFkaXVzUG9pbnQgPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDE2OiAvLyBQb2ludCBkZWZpbmluZyBkaW1lbnNpb24gYXJjIGZvciBhbmd1bGFyIGRpbWVuc2lvbnNcclxuXHRcdFx0XHRcdGVudGl0eS5hcmNQb2ludCA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNzA6IC8vIERpbWVuc2lvbiB0eXBlXHJcblx0XHRcdFx0XHRlbnRpdHkuZGltZW5zaW9uVHlwZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDcxOiAvLyA1ID0gTWlkZGxlIGNlbnRlclxyXG5cdFx0XHRcdFx0ZW50aXR5LmF0dGFjaG1lbnRQb2ludCA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDQyOiAvLyBBY3R1YWwgbWVhc3VyZW1lbnRcclxuXHRcdFx0XHRcdGVudGl0eS5hY3R1YWxNZWFzdXJlbWVudCA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDE6IC8vIFRleHQgZW50ZXJlZCBieSB1c2VyIGV4cGxpY2l0bHlcclxuXHRcdFx0XHRcdGVudGl0eS50ZXh0ID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNTA6IC8vIEFuZ2xlIG9mIHJvdGF0ZWQsIGhvcml6b250YWwsIG9yIHZlcnRpY2FsIGRpbWVuc2lvbnNcclxuXHRcdFx0XHRcdGVudGl0eS5hbmdsZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OiAvLyBjaGVjayBjb21tb24gZW50aXR5IGF0dHJpYnV0ZXNcclxuXHRcdFx0XHRcdGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVudGl0eTtcclxufTtcclxuXHJcblxyXG4iLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnRUxMSVBTRSc7XHJcblxyXG5FbnRpdHlQYXJzZXIucHJvdG90eXBlLnBhcnNlRW50aXR5ID0gZnVuY3Rpb24oc2Nhbm5lciwgY3Vycikge1xyXG4gICAgdmFyIGVudGl0eTtcclxuICAgIGVudGl0eSA9IHsgdHlwZTogY3Vyci52YWx1ZSB9O1xyXG4gICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgd2hpbGUoY3VyciAhPT0gJ0VPRicpIHtcclxuICAgICAgICBpZihjdXJyLmNvZGUgPT09IDApIGJyZWFrO1xyXG5cclxuICAgICAgICBzd2l0Y2goY3Vyci5jb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuY2VudGVyID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQgPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5heGlzUmF0aW8gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc3RhcnRBbmdsZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MjpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5lbmRBbmdsZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm5hbWUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIGNoZWNrIGNvbW1vbiBlbnRpdHkgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgaGVscGVycy5jaGVja0NvbW1vbkVudGl0eVByb3BlcnRpZXMoZW50aXR5LCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnSU5TRVJUJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5O1xyXG4gICAgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm5hbWUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkueFNjYWxlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQyOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnlTY2FsZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MzpcclxuICAgICAgICAgICAgICAgIGVudGl0eS56U2NhbGUgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucG9zaXRpb24gPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1MDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5yb3RhdGlvbiA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5jb2x1bW5Db3VudCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MTpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5yb3dDb3VudCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0NDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5jb2x1bW5TcGFjaW5nID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ1OlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnJvd1NwYWNpbmcgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjEwOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dHJ1c2lvbkRpcmVjdGlvbiA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiAvLyBjaGVjayBjb21tb24gZW50aXR5IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbnRpdHk7XHJcbn07XHJcblxyXG5cclxuIiwiXHJcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vUGFyc2VIZWxwZXJzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRW50aXR5UGFyc2VyKCkge31cclxuXHJcbkVudGl0eVBhcnNlci5Gb3JFbnRpdHlOYW1lID0gJ0xJTkUnO1xyXG5cclxuRW50aXR5UGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uKHNjYW5uZXIsIGN1cnIpIHtcclxuICAgIHZhciBlbnRpdHkgPSB7IHR5cGU6IGN1cnIudmFsdWUsIHZlcnRpY2VzOiBbXSB9O1xyXG4gICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgd2hpbGUoY3VyciAhPT0gJ0VPRicpIHtcclxuICAgICAgICBpZihjdXJyLmNvZGUgPT09IDApIGJyZWFrO1xyXG5cclxuICAgICAgICBzd2l0Y2goY3Vyci5jb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IC8vIFggY29vcmRpbmF0ZSBvZiBwb2ludFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnZlcnRpY2VzLnVuc2hpZnQoaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnZlcnRpY2VzLnB1c2goaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIxMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb24gPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMDA6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnTFdQT0xZTElORSc7XHJcblxyXG5FbnRpdHlQYXJzZXIucHJvdG90eXBlLnBhcnNlRW50aXR5ID0gZnVuY3Rpb24oc2Nhbm5lciwgY3Vycikge1xyXG4gICAgdmFyIGVudGl0eSA9IHsgdHlwZTogY3Vyci52YWx1ZSwgdmVydGljZXM6IFtdIH0sXHJcbiAgICAgICAgbnVtYmVyT2ZWZXJ0aWNlcyA9IDA7XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAzODpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5lbGV2YXRpb24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZGVwdGggPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzA6IC8vIDEgPSBDbG9zZWQgc2hhcGUsIDEyOCA9IHBsaW5lZ2VuPywgMCA9IGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zaGFwZSA9ICgoY3Vyci52YWx1ZSAmIDEpID09PSAxKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5oYXNDb250aW51b3VzTGluZXR5cGVQYXR0ZXJuID0gKChjdXJyLnZhbHVlICYgMTI4KSA9PT0gMTI4KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDkwOlxyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZWZXJ0aWNlcyA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMDogLy8gWCBjb29yZGluYXRlIG9mIHBvaW50XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudmVydGljZXMgPSBwYXJzZUxXUG9seWxpbmVWZXJ0aWNlcyhudW1iZXJPZlZlcnRpY2VzLCBzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQzOlxyXG4gICAgICAgICAgICAgICAgaWYoY3Vyci52YWx1ZSAhPT0gMCkgZW50aXR5LndpZHRoID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIxMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25YID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIyMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25ZID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIzMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb25aID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaGVscGVycy5jaGVja0NvbW1vbkVudGl0eVByb3BlcnRpZXMoZW50aXR5LCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50aXR5O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcGFyc2VMV1BvbHlsaW5lVmVydGljZXMobiwgc2Nhbm5lcikge1xyXG4gICAgaWYoIW4gfHwgbiA8PSAwKSB0aHJvdyBFcnJvcignbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHZlcnRpY2llcycpO1xyXG4gICAgdmFyIHZlcnRpY2VzID0gW10sIGk7XHJcbiAgICB2YXIgdmVydGV4SXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICB2YXIgdmVydGV4SXNGaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGN1cnIgPSBzY2FubmVyLmxhc3RSZWFkR3JvdXA7XHJcblxyXG4gICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHZlcnRleCA9IHt9O1xyXG4gICAgICAgIHdoaWxlKGN1cnIgIT09ICdFT0YnKSB7XHJcbiAgICAgICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCB8fCB2ZXJ0ZXhJc0ZpbmlzaGVkKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTA6IC8vIFhcclxuICAgICAgICAgICAgICAgICAgICBpZih2ZXJ0ZXhJc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4SXNGaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4SXNTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjA6IC8vIFlcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyBaXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4LnogPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0MDogLy8gc3RhcnQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXguc3RhcnRXaWR0aCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQxOiAvLyBlbmQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXguZW5kV2lkdGggPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0MjogLy8gYnVsZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyLnZhbHVlICE9IDApIHZlcnRleC5idWxnZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRvIG5vdCBoaXQga25vd24gY29kZSByZXR1cm4gdmVydGljZXMuICBDb2RlIG1pZ2h0IGJlbG9uZyB0byBlbnRpdHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4SXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nhbm5lci5yZXdpbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXRvcGljL2NvbXAuY2FkLmF1dG9jYWQvOWduOHM1T193NkVcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgdmVydGV4SXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmVydGV4SXNGaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc2Nhbm5lci5yZXdpbmQoKTtcclxuICAgIHJldHVybiB2ZXJ0aWNlcztcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnTVRFWFQnO1xyXG5cclxuRW50aXR5UGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uKHNjYW5uZXIsIGN1cnIpIHtcclxuICAgIHZhciBlbnRpdHkgPSB7IHR5cGU6IGN1cnIudmFsdWUgfTtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIHdoaWxlKGN1cnIgIT09ICdFT0YnKSB7XHJcbiAgICAgICAgaWYoY3Vyci5jb2RlID09PSAwKSBicmVhaztcclxuXHJcbiAgICAgICAgc3dpdGNoKGN1cnIuY29kZSkge1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudGV4dCA/IGVudGl0eS50ZXh0ICs9IGN1cnIudmFsdWUgOiBlbnRpdHkudGV4dCA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRleHQgPyBlbnRpdHkudGV4dCArPSBjdXJyLnZhbHVlIDogZW50aXR5LnRleHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucG9zaXRpb24gPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MDpcclxuICAgICAgICAgICAgICAgIC8vTm90ZTogdGhpcyBpcyB0aGUgdGV4dCBoZWlnaHRcclxuICAgICAgICAgICAgICAgIGVudGl0eS5oZWlnaHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkud2lkdGggPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucm90YXRpb24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuYXR0YWNobWVudFBvaW50ID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDcyOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmRyYXdpbmdEaXJlY3Rpb24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRpdHk7XHJcbn07IiwiXHJcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vUGFyc2VIZWxwZXJzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRW50aXR5UGFyc2VyKCkge31cclxuXHJcbkVudGl0eVBhcnNlci5Gb3JFbnRpdHlOYW1lID0gJ1BPSU5UJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5O1xyXG4gICAgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5wb3NpdGlvbiA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRoaWNrbmVzcyA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXh0cnVzaW9uRGlyZWN0aW9uID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTAwOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIGNoZWNrIGNvbW1vbiBlbnRpdHkgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgaGVscGVycy5jaGVja0NvbW1vbkVudGl0eVByb3BlcnRpZXMoZW50aXR5LCBjdXJyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnVkVSVEVYJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxMDpcdC8vIFhcclxuICAgICAgICAgICAgICAgIGVudGl0eS54ID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIwOiAvLyBZXHJcbiAgICAgICAgICAgICAgICBlbnRpdHkueSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzMDogLy8gWlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnogPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vIHN0YXJ0IHdpZHRoXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MTogLy8gZW5kIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0MjogLy8gYnVsZ2VcclxuICAgICAgICAgICAgICAgIGlmKGN1cnIudmFsdWUgIT0gMCkgZW50aXR5LmJ1bGdlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDcwOiAvLyBmbGFnc1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmN1cnZlRml0dGluZ1ZlcnRleCA9IChjdXJyLnZhbHVlICYgMSkgIT09IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuY3VydmVGaXRUYW5nZW50ID0gKGN1cnIudmFsdWUgJiAyKSAhPT0gMDtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zcGxpbmVWZXJ0ZXggPSAoY3Vyci52YWx1ZSAmIDgpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnNwbGluZUNvbnRyb2xQb2ludCA9IChjdXJyLnZhbHVlICYgMTYpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRocmVlRFBvbHlsaW5lVmVydGV4ID0gKGN1cnIudmFsdWUgJiAzMikgIT09IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudGhyZWVEUG9seWxpbmVNZXNoID0gKGN1cnIudmFsdWUgJiA2NCkgIT09IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucG9seWZhY2VNZXNoVmVydGV4ID0gKGN1cnIudmFsdWUgJiAxMjgpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTA6IC8vIGN1cnZlIGZpdCB0YW5nZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzE6IC8vIHBvbHlmYWNlIG1lc2ggdmVydGV4IGluZGV4XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZmFjZUEgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzI6IC8vIHBvbHlmYWNlIG1lc2ggdmVydGV4IGluZGV4XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZmFjZUIgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzM6IC8vIHBvbHlmYWNlIG1lc2ggdmVydGV4IGluZGV4XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZmFjZUMgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzQ6IC8vIHBvbHlmYWNlIG1lc2ggdmVydGV4IGluZGV4XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZmFjZUQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRpdHk7XHJcbn07IiwiXHJcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vUGFyc2VIZWxwZXJzJ1xyXG5pbXBvcnQgVmVydGV4UGFyc2VyIGZyb20gJy4vdmVydGV4JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVudGl0eVBhcnNlcigpIHt9XHJcblxyXG5FbnRpdHlQYXJzZXIuRm9yRW50aXR5TmFtZSA9ICdQT0xZTElORSc7XHJcblxyXG5FbnRpdHlQYXJzZXIucHJvdG90eXBlLnBhcnNlRW50aXR5ID0gZnVuY3Rpb24oc2Nhbm5lciwgY3Vycikge1xyXG4gICAgdmFyIGVudGl0eSA9IHsgdHlwZTogY3Vyci52YWx1ZSwgdmVydGljZXM6IFtdIH07XHJcblx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHR3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG5cdFx0XHRpZihjdXJyLmNvZGUgPT09IDApIGJyZWFrO1xyXG5cclxuXHRcdFx0c3dpdGNoKGN1cnIuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gYWx3YXlzIDBcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdFx0XHRjYXNlIDIwOiAvLyBhbHdheXMgMFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMzA6IC8vIGVsZXZhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMzk6IC8vIHRoaWNrbmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS50aGlja25lc3MgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA0MDogLy8gc3RhcnQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdFx0XHRjYXNlIDQxOiAvLyBlbmQgd2lkdGhcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNzA6XHJcblx0XHRcdFx0XHRlbnRpdHkuc2hhcGUgPSAoY3Vyci52YWx1ZSAmIDEpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5pbmNsdWRlc0N1cnZlRml0VmVydGljZXMgPSAoY3Vyci52YWx1ZSAmIDIpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5pbmNsdWRlc1NwbGluZUZpdFZlcnRpY2VzID0gKGN1cnIudmFsdWUgJiA0KSAhPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuaXMzZFBvbHlsaW5lID0gKGN1cnIudmFsdWUgJiA4KSAhPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuaXMzZFBvbHlnb25NZXNoID0gKGN1cnIudmFsdWUgJiAxNikgIT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5LmlzM2RQb2x5Z29uTWVzaENsb3NlZCA9IChjdXJyLnZhbHVlICYgMzIpICE9PSAwOyAvLyAzMiA9IFRoZSBwb2x5Z29uIG1lc2ggaXMgY2xvc2VkIGluIHRoZSBOIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5pc1BvbHlmYWNlTWVzaCA9IChjdXJyLnZhbHVlICYgNjQpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5oYXNDb250aW51b3VzTGluZXR5cGVQYXR0ZXJuID0gKGN1cnIudmFsdWUgJiAxMjgpICE9PSAwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3MTogLy8gUG9seWdvbiBtZXNoIE0gdmVydGV4IGNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3MjogLy8gUG9seWdvbiBtZXNoIE4gdmVydGV4IGNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3MzogLy8gU21vb3RoIHN1cmZhY2UgTSBkZW5zaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3NDogLy8gU21vb3RoIHN1cmZhY2UgTiBkZW5zaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3NTogLy8gQ3VydmVzIGFuZCBzbW9vdGggc3VyZmFjZSB0eXBlXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDIxMDpcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuZXh0cnVzaW9uRGlyZWN0aW9uID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGhlbHBlcnMuY2hlY2tDb21tb25FbnRpdHlQcm9wZXJ0aWVzKGVudGl0eSwgY3Vycik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZW50aXR5LnZlcnRpY2VzID0gcGFyc2VQb2x5bGluZVZlcnRpY2VzKHNjYW5uZXIsIGN1cnIpO1xyXG5cclxuXHRcdHJldHVybiBlbnRpdHk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZVBvbHlsaW5lVmVydGljZXMoc2Nhbm5lciwgY3Vycikge1xyXG4gICAgdmFyIHZlcnRleFBhcnNlciA9IG5ldyBWZXJ0ZXhQYXJzZXIoKTtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcclxuICAgIHdoaWxlICghc2Nhbm5lci5pc0VPRigpKSB7XHJcbiAgICAgICAgaWYgKGN1cnIuY29kZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoY3Vyci52YWx1ZSA9PT0gJ1ZFUlRFWCcpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4UGFyc2VyLnBhcnNlRW50aXR5KHNjYW5uZXIsIGN1cnIpKTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSBzY2FubmVyLmxhc3RSZWFkR3JvdXA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Vyci52YWx1ZSA9PT0gJ1NFUUVORCcpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlU2VxRW5kKHNjYW5uZXIsIGN1cnIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmVydGljZXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZVNlcUVuZChzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9ICdFT0YnKSB7XHJcbiAgICAgICAgaWYgKGN1cnIuY29kZSA9PSAwKSBicmVhaztcclxuICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnIpO1xyXG4gICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW50aXR5O1xyXG59O1xyXG4iLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnU09MSUQnO1xyXG5cclxuRW50aXR5UGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudGl0eSA9IGZ1bmN0aW9uKHNjYW5uZXIsIGN1cnJlbnRHcm91cCkge1xyXG4gICAgdmFyIGVudGl0eTtcclxuICAgIGVudGl0eSA9IHsgdHlwZTogY3VycmVudEdyb3VwLnZhbHVlIH07XHJcbiAgICBlbnRpdHkucG9pbnRzID0gW107XHJcbiAgICBjdXJyZW50R3JvdXAgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIHdoaWxlKGN1cnJlbnRHcm91cCAhPT0gJ0VPRicpIHtcclxuICAgICAgICBpZihjdXJyZW50R3JvdXAuY29kZSA9PT0gMCkgYnJlYWs7XHJcblxyXG4gICAgICAgIHN3aXRjaChjdXJyZW50R3JvdXAuY29kZSkge1xyXG4gICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnBvaW50c1swXSA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnBvaW50c1sxXSA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnBvaW50c1syXSA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnBvaW50c1szXSA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIxMDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb24gPSBoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogLy8gY2hlY2sgY29tbW9uIGVudGl0eSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnJlbnRHcm91cCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEdyb3VwID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVudGl0eTtcclxufTsiLCJcclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9QYXJzZUhlbHBlcnMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbnRpdHlQYXJzZXIoKSB7fVxyXG5cclxuRW50aXR5UGFyc2VyLkZvckVudGl0eU5hbWUgPSAnU1BMSU5FJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5O1xyXG4gICAgZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJylcclxuICAgIHtcclxuICAgICAgICBpZihjdXJyLmNvZGUgPT09IDApIGJyZWFrO1xyXG5cclxuICAgICAgICBzd2l0Y2goY3Vyci5jb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eS5jb250cm9sUG9pbnRzKSBlbnRpdHkuY29udHJvbFBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmNvbnRyb2xQb2ludHMucHVzaChoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcikpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eS5maXRQb2ludHMpIGVudGl0eS5maXRQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5maXRQb2ludHMucHVzaChoZWxwZXJzLnBhcnNlUG9pbnQoc2Nhbm5lcikpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc3RhcnRUYW5nZW50ID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZW5kVGFuZ2VudCA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQwOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbnRpdHkua25vdFZhbHVlcykgZW50aXR5Lmtub3RWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5rbm90VmFsdWVzLnB1c2goY3Vyci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MDpcclxuICAgICAgICAgICAgICAgIGlmICgoY3Vyci52YWx1ZSAmIDEpICE9IDApIGVudGl0eS5jbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyLnZhbHVlICYgMikgIT0gMCkgZW50aXR5LnBlcmlvZGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgoY3Vyci52YWx1ZSAmIDQpICE9IDApIGVudGl0eS5yYXRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnIudmFsdWUgJiA4KSAhPSAwKSBlbnRpdHkucGxhbmFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgoY3Vyci52YWx1ZSAmIDE2KSAhPSAwKSBcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkucGxhbmFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkubGluZWFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgNzE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZGVncmVlT2ZTcGxpbmVDdXJ2ZSA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3MjpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5udW1iZXJPZktub3RzID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDczOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm51bWJlck9mQ29udHJvbFBvaW50cyA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3NDpcclxuICAgICAgICAgICAgICAgIGVudGl0eS5udW1iZXJPZkZpdFBvaW50cyA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMTA6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkubm9ybWFsVmVjdG9yID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW50aXR5O1xyXG59OyIsIlxyXG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uL1BhcnNlSGVscGVycydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVudGl0eVBhcnNlcigpIHt9XHJcblxyXG5FbnRpdHlQYXJzZXIuRm9yRW50aXR5TmFtZSA9ICdURVhUJztcclxuXHJcbkVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbihzY2FubmVyLCBjdXJyKSB7XHJcbiAgICB2YXIgZW50aXR5O1xyXG5cdFx0ZW50aXR5ID0geyB0eXBlOiBjdXJyLnZhbHVlIH07XHJcbiAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICB3aGlsZShjdXJyICE9PSAnRU9GJykge1xyXG4gICAgICAgIGlmKGN1cnIuY29kZSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgc3dpdGNoKGN1cnIuY29kZSkge1xyXG4gICAgICAgICAgICBjYXNlIDEwOiAvLyBYIGNvb3JkaW5hdGUgb2YgJ2ZpcnN0IGFsaWdubWVudCBwb2ludCdcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zdGFydFBvaW50ID0gaGVscGVycy5wYXJzZVBvaW50KHNjYW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIFggY29vcmRpbmF0ZSBvZiAnc2Vjb25kIGFsaWdubWVudCBwb2ludCdcclxuICAgICAgICAgICAgICAgIGVudGl0eS5lbmRQb2ludCA9IGhlbHBlcnMucGFyc2VQb2ludChzY2FubmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQwOiAvLyBUZXh0IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRleHRIZWlnaHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDE6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkueFNjYWxlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDUwOiAvLyBSb3RhdGlvbiBpbiBkZWdyZWVzXHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucm90YXRpb24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTogLy8gVGV4dFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnRleHQgPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IDcyIGFuZCA3MyBhcmUgbWVhbmluZ2xlc3Mgd2l0aG91dCAxMSAoc2Vjb25kIGFsaWdubWVudCBwb2ludClcclxuICAgICAgICAgICAgY2FzZSA3MjogLy8gSG9yaXpvbnRhbCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgIGVudGl0eS5oYWxpZ24gPSBjdXJyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNzM6IC8vIFZlcnRpY2FsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnZhbGlnbiA9IGN1cnIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogLy8gY2hlY2sgY29tbW9uIGVudGl0eSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmNoZWNrQ29tbW9uRW50aXR5UHJvcGVydGllcyhlbnRpdHksIGN1cnIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRpdHk7XHJcbn07IiwiaW1wb3J0IER4ZkFycmF5U2Nhbm5lciBmcm9tICcuL0R4ZkFycmF5U2Nhbm5lcic7XHJcbmltcG9ydCBBVVRPX0NBRF9DT0xPUl9JTkRFWCBmcm9tICcuL0F1dG9DYWRDb2xvckluZGV4JztcclxuXHJcbmltcG9ydCBGYWNlIGZyb20gJy4vZW50aXRpZXMvM2RmYWNlJztcclxuaW1wb3J0IEFyYyBmcm9tICcuL2VudGl0aWVzL2FyYyc7XHJcbmltcG9ydCBBdHREZWYgZnJvbSAnLi9lbnRpdGllcy9hdHRkZWYnO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4vZW50aXRpZXMvY2lyY2xlJztcclxuaW1wb3J0IERpbWVuc2lvbiBmcm9tICcuL2VudGl0aWVzL2RpbWVuc2lvbic7XHJcbmltcG9ydCBFbGxpcHNlIGZyb20gJy4vZW50aXRpZXMvZWxsaXBzZSc7XHJcbmltcG9ydCBJbnNlcnQgZnJvbSAnLi9lbnRpdGllcy9pbnNlcnQnO1xyXG5pbXBvcnQgTGluZSBmcm9tICcuL2VudGl0aWVzL2xpbmUnO1xyXG5pbXBvcnQgTFdQb2x5bGluZSBmcm9tICcuL2VudGl0aWVzL2x3cG9seWxpbmUnO1xyXG5pbXBvcnQgTVRleHQgZnJvbSAnLi9lbnRpdGllcy9tdGV4dCc7XHJcbmltcG9ydCBQb2ludCBmcm9tICcuL2VudGl0aWVzL3BvaW50JztcclxuaW1wb3J0IFBvbHlsaW5lIGZyb20gJy4vZW50aXRpZXMvcG9seWxpbmUnO1xyXG5pbXBvcnQgU29saWQgZnJvbSAnLi9lbnRpdGllcy9zb2xpZCc7XHJcbmltcG9ydCBTcGxpbmUgZnJvbSAnLi9lbnRpdGllcy9zcGxpbmUnO1xyXG5pbXBvcnQgVGV4dCBmcm9tICcuL2VudGl0aWVzL3RleHQnO1xyXG4vL2ltcG9ydCBWZXJ0ZXggZnJvbSAnLi9lbnRpdGllcy8nO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG4vL2xvZy5zZXRMZXZlbCgndHJhY2UnKTtcclxuLy9sb2cuc2V0TGV2ZWwoJ2RlYnVnJyk7XHJcbi8vbG9nLnNldExldmVsKCdpbmZvJyk7XHJcbi8vbG9nLnNldExldmVsKCd3YXJuJyk7XHJcbmxvZy5zZXRMZXZlbCgnZXJyb3InKTtcclxuLy9sb2cuc2V0TGV2ZWwoJ3NpbGVudCcpO1xyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RW50aXR5SGFuZGxlcnMoZHhmUGFyc2VyKSB7XHJcblx0Ly8gU3VwcG9ydGVkIGVudGl0aWVzIGhlcmUgKHNvbWUgZW50aXR5IGNvZGUgaXMgc3RpbGwgYmVpbmcgcmVmYWN0b3JlZCBpbnRvIHRoaXMgZmxvdylcclxuXHRkeGZQYXJzZXIucmVnaXN0ZXJFbnRpdHlIYW5kbGVyKEZhY2UpO1xyXG5cdGR4ZlBhcnNlci5yZWdpc3RlckVudGl0eUhhbmRsZXIoQXJjKTtcclxuXHRkeGZQYXJzZXIucmVnaXN0ZXJFbnRpdHlIYW5kbGVyKEF0dERlZik7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihDaXJjbGUpO1xyXG5cdGR4ZlBhcnNlci5yZWdpc3RlckVudGl0eUhhbmRsZXIoRGltZW5zaW9uKTtcclxuXHRkeGZQYXJzZXIucmVnaXN0ZXJFbnRpdHlIYW5kbGVyKEVsbGlwc2UpO1xyXG5cdGR4ZlBhcnNlci5yZWdpc3RlckVudGl0eUhhbmRsZXIoSW5zZXJ0KTtcclxuXHRkeGZQYXJzZXIucmVnaXN0ZXJFbnRpdHlIYW5kbGVyKExpbmUpO1xyXG5cdGR4ZlBhcnNlci5yZWdpc3RlckVudGl0eUhhbmRsZXIoTFdQb2x5bGluZSk7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihNVGV4dCk7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihQb2ludCk7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihQb2x5bGluZSk7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihTb2xpZCk7XHJcblx0ZHhmUGFyc2VyLnJlZ2lzdGVyRW50aXR5SGFuZGxlcihTcGxpbmUpO1xyXG5cdGR4ZlBhcnNlci5yZWdpc3RlckVudGl0eUhhbmRsZXIoVGV4dCk7XHJcblx0Ly9keGZQYXJzZXIucmVnaXN0ZXJFbnRpdHlIYW5kbGVyKHJlcXVpcmUoJy4vZW50aXRpZXMvdmVydGV4JykpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEeGZQYXJzZXIoKSB7XHJcblx0dGhpcy5fZW50aXR5SGFuZGxlcnMgPSB7fTtcclxuXHJcblx0cmVnaXN0ZXJEZWZhdWx0RW50aXR5SGFuZGxlcnModGhpcyk7XHJcbn1cclxuXHJcbkR4ZlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzb3VyY2UsIGRvbmUpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJyZWFkKCkgbm90IGltcGxlbWVudGVkLiBVc2UgcmVhZFN5bmMoKVwiKTtcclxufTtcclxuXHJcbkR4ZlBhcnNlci5wcm90b3R5cGUucmVnaXN0ZXJFbnRpdHlIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlclR5cGUpIHtcclxuXHR2YXIgaW5zdGFuY2UgPSBuZXcgaGFuZGxlclR5cGUoKTtcclxuXHR0aGlzLl9lbnRpdHlIYW5kbGVyc1toYW5kbGVyVHlwZS5Gb3JFbnRpdHlOYW1lXSA9IGluc3RhbmNlO1xyXG59XHJcblxyXG5EeGZQYXJzZXIucHJvdG90eXBlLnBhcnNlU3luYyA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cdGlmKHR5cGVvZihzb3VyY2UpID09PSAnc3RyaW5nJykge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhcnNlKHNvdXJjZSk7XHJcblx0fWVsc2Uge1xyXG5cdFx0Y29uc29sZS5lcnJvcignQ2Fubm90IHJlYWQgZHhmIHNvdXJjZSBvZiB0eXBlIGAnICsgdHlwZW9mKHNvdXJjZSkpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG59O1xyXG5cclxuRHhmUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSwgZG9uZSkge1xyXG5cclxuXHR2YXIgZHhmU3RyaW5nID0gXCJcIjtcclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdHN0cmVhbS5vbignZGF0YScsIG9uRGF0YSk7XHJcblx0c3RyZWFtLm9uKCdlbmQnLCBvbkVuZCk7XHJcblx0c3RyZWFtLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xyXG5cclxuXHRmdW5jdGlvbiBvbkRhdGEoY2h1bmspIHtcclxuXHRcdGR4ZlN0cmluZyArPSBjaHVuaztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uRW5kKCkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dmFyIGR4ZiA9IHNlbGYuX3BhcnNlKGR4ZlN0cmluZyk7XHJcblx0XHR9Y2F0Y2goZXJyKSB7XHJcblx0XHRcdHJldHVybiBkb25lKGVycik7XHJcblx0XHR9XHJcblx0XHRkb25lKG51bGwsIGR4Zik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbkVycm9yKGVycikge1xyXG5cdFx0ZG9uZShlcnIpO1xyXG5cdH1cclxufTtcclxuXHJcbkR4ZlBhcnNlci5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24oZHhmU3RyaW5nKSB7XHJcblx0dmFyIHNjYW5uZXIsIGN1cnIsIGR4ZiA9IHt9LCBsYXN0SGFuZGxlID0gMDtcclxuXHR2YXIgZHhmTGluZXNBcnJheSA9IGR4ZlN0cmluZy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyk7XHJcblxyXG5cdHNjYW5uZXIgPSBuZXcgRHhmQXJyYXlTY2FubmVyKGR4ZkxpbmVzQXJyYXkpO1xyXG5cdGlmKCFzY2FubmVyLmhhc05leHQoKSkgdGhyb3cgRXJyb3IoJ0VtcHR5IGZpbGUnKTtcclxuXHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHR2YXIgcGFyc2VBbGwgPSBmdW5jdGlvbigpIHtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHdoaWxlKCFzY2FubmVyLmlzRU9GKCkpIHtcclxuXHRcdFx0aWYoY3Vyci5jb2RlID09PSAwICYmIGN1cnIudmFsdWUgPT09ICdTRUNUSU9OJykge1xyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHJcblx0XHRcdFx0Ly8gQmUgc3VyZSB3ZSBhcmUgcmVhZGluZyBhIHNlY3Rpb24gY29kZVxyXG5cdFx0XHRcdGlmIChjdXJyLmNvZGUgIT09IDIpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgY29kZSAlcyBhZnRlciAwOlNFQ1RJT04nLCBkZWJ1Z0NvZGUoY3VycikpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY3Vyci52YWx1ZSA9PT0gJ0hFQURFUicpIHtcclxuXHRcdFx0XHRcdGxvZy5kZWJ1ZygnPiBIRUFERVInKTtcclxuXHRcdFx0XHRcdGR4Zi5oZWFkZXIgPSBwYXJzZUhlYWRlcigpO1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCc8Jyk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyLnZhbHVlID09PSAnQkxPQ0tTJykge1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCc+IEJMT0NLUycpO1xyXG5cdFx0XHRcdFx0ZHhmLmJsb2NrcyA9IHBhcnNlQmxvY2tzKCk7XHJcblx0XHRcdFx0XHRsb2cuZGVidWcoJzwnKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoY3Vyci52YWx1ZSA9PT0gJ0VOVElUSUVTJykge1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCc+IEVOVElUSUVTJyk7XHJcblx0XHRcdFx0XHRkeGYuZW50aXRpZXMgPSBwYXJzZUVudGl0aWVzKGZhbHNlKTtcclxuXHRcdFx0XHRcdGxvZy5kZWJ1ZygnPCcpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihjdXJyLnZhbHVlID09PSAnVEFCTEVTJykge1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCc+IFRBQkxFUycpO1xyXG5cdFx0XHRcdFx0ZHhmLnRhYmxlcyA9IHBhcnNlVGFibGVzKCk7XHJcblx0XHRcdFx0XHRsb2cuZGVidWcoJzwnKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoY3Vyci52YWx1ZSA9PT0gJ0VPRicpIHtcclxuXHRcdFx0XHRcdGxvZy5kZWJ1ZygnRU9GJyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxvZy53YXJuKCdTa2lwcGluZyBzZWN0aW9uIFxcJyVzXFwnJywgY3Vyci52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBJZiBpcyBhIG5ldyBzZWN0aW9uXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIGdyb3VwSXMgPSBmdW5jdGlvbihjb2RlLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGN1cnIuY29kZSA9PT0gY29kZSAmJiBjdXJyLnZhbHVlID09PSB2YWx1ZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge29iamVjdH0gaGVhZGVyXHJcblx0ICovXHJcblx0dmFyIHBhcnNlSGVhZGVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHQvLyBpbnRlcmVzdGluZyB2YXJpYWJsZXM6XHJcblx0XHQvLyAgJEFDQURWRVIsICRWSUVXRElSLCAkVklFV1NJWkUsICRWSUVXQ1RSLCAkVERDUkVBVEUsICRURFVQREFURVxyXG5cdFx0Ly8gaHR0cDovL3d3dy5hdXRvZGVzay5jb20vdGVjaHB1YnMvYXV0b2NhZC9hY2FkcjE0L2R4Zi9oZWFkZXJfc2VjdGlvbl9hbF91MDVfYy5odG1cclxuXHRcdC8vIEFsc28gc2VlIFZQT1JUIHRhYmxlIGVudHJpZXNcclxuXHRcdHZhciBjdXJyVmFyTmFtZSA9IG51bGwsIGN1cnJWYXJWYWx1ZSA9IG51bGw7XHJcblx0XHR2YXIgaGVhZGVyID0ge307XHJcblx0XHQvLyBsb29wIHRocm91Z2ggaGVhZGVyIHZhcmlhYmxlc1xyXG5cdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cclxuXHRcdHdoaWxlKHRydWUpIHtcclxuXHRcdFx0aWYoZ3JvdXBJcygwLCAnRU5EU0VDJykpIHtcclxuXHRcdFx0XHRpZihjdXJyVmFyTmFtZSkgaGVhZGVyW2N1cnJWYXJOYW1lXSA9IGN1cnJWYXJWYWx1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fSBlbHNlIGlmKGN1cnIuY29kZSA9PT0gOSkge1xyXG5cdFx0XHRcdGlmKGN1cnJWYXJOYW1lKSBoZWFkZXJbY3VyclZhck5hbWVdID0gY3VyclZhclZhbHVlO1xyXG5cdFx0XHRcdGN1cnJWYXJOYW1lID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHQvLyBGaWx0ZXIgaGVyZSBmb3IgcGFydGljdWxhciB2YXJpYWJsZXMgd2UgYXJlIGludGVyZXN0ZWQgaW5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZihjdXJyLmNvZGUgPT09IDEwKSB7XHJcblx0XHRcdFx0XHRjdXJyVmFyVmFsdWUgPSB7IHg6IGN1cnIudmFsdWUgfTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoY3Vyci5jb2RlID09PSAyMCkge1xyXG5cdFx0XHRcdFx0Y3VyclZhclZhbHVlLnkgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihjdXJyLmNvZGUgPT09IDMwKSB7XHJcblx0XHRcdFx0XHRjdXJyVmFyVmFsdWUueiA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGN1cnJWYXJWYWx1ZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdH1cclxuXHRcdC8vIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChoZWFkZXIsIHsgY29sb3JzOiB0cnVlLCBkZXB0aDogbnVsbCB9KSk7XHJcblx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7IC8vIHN3YWxsb3cgdXAgRU5EU0VDXHJcblx0XHRyZXR1cm4gaGVhZGVyO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqL1xyXG5cdHZhciBwYXJzZUJsb2NrcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGJsb2NrcyA9IHt9LCBibG9jaztcclxuXHJcbiAgICAgICAgY3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cclxuXHRcdHdoaWxlKGN1cnIudmFsdWUgIT09ICdFT0YnKSB7XHJcblx0XHRcdGlmKGdyb3VwSXMoMCwgJ0VORFNFQycpKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGdyb3VwSXMoMCwgJ0JMT0NLJykpIHtcclxuXHRcdFx0XHRsb2cuZGVidWcoJ2Jsb2NrIHsnKTtcclxuXHRcdFx0XHRibG9jayA9IHBhcnNlQmxvY2soKTtcclxuXHRcdFx0XHRsb2cuZGVidWcoJ30nKTtcclxuXHRcdFx0XHRlbnN1cmVIYW5kbGUoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgaWYoIWJsb2NrLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKCdibG9jayB3aXRoIGhhbmRsZSBcIicgKyBibG9jay5oYW5kbGUgKyAnXCIgaXMgbWlzc2luZyBhIG5hbWUuJyk7XHJcblx0XHRcdFx0ZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tibG9jay5uYW1lXSA9IGJsb2NrO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxvZ1VuaGFuZGxlZEdyb3VwKGN1cnIpO1xyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJsb2NrcztcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyc2VCbG9jayA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGJsb2NrID0ge307XHJcblx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblxyXG5cdFx0d2hpbGUoY3Vyci52YWx1ZSAhPT0gJ0VPRicpIHtcclxuXHRcdFx0c3dpdGNoKGN1cnIuY29kZSkge1xyXG5cdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdGJsb2NrLnhyZWZQYXRoID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRcdGJsb2NrLm5hbWUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0YmxvY2submFtZTIgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA1OlxyXG5cdFx0XHRcdFx0YmxvY2suaGFuZGxlID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgODpcclxuXHRcdFx0XHRcdGJsb2NrLmxheWVyID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTA6XHJcblx0XHRcdFx0XHRibG9jay5wb3NpdGlvbiA9IHBhcnNlUG9pbnQoKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNjc6XHJcblx0XHRcdFx0XHRibG9jay5wYXBlclNwYWNlID0gKGN1cnIudmFsdWUgJiYgY3Vyci52YWx1ZSA9PSAxKSA/IHRydWUgOiBmYWxzZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNzA6XHJcblx0XHRcdFx0XHRpZiAoY3Vyci52YWx1ZSAhPSAwKSB7XHJcblx0XHRcdFx0XHRcdC8vaWYoY3Vyci52YWx1ZSAmIEJMT0NLX0FOT05ZTU9VU19GTEFHKSBjb25zb2xlLmxvZygnICBBbm9ueW1vdXMgYmxvY2snKTtcclxuXHRcdFx0XHRcdFx0Ly9pZihjdXJyLnZhbHVlICYgQkxPQ0tfTk9OX0NPTlNUQU5UX0ZMQUcpIGNvbnNvbGUubG9nKCcgIE5vbi1jb25zdGFudCBhdHRyaWJ1dGVzJyk7XHJcblx0XHRcdFx0XHRcdC8vaWYoY3Vyci52YWx1ZSAmIEJMT0NLX1hSRUZfRkxBRykgY29uc29sZS5sb2coJyAgSXMgeHJlZicpO1xyXG5cdFx0XHRcdFx0XHQvL2lmKGN1cnIudmFsdWUgJiBCTE9DS19YUkVGX09WRVJMQVlfRkxBRykgY29uc29sZS5sb2coJyAgSXMgeHJlZiBvdmVybGF5Jyk7XHJcblx0XHRcdFx0XHRcdC8vaWYoY3Vyci52YWx1ZSAmIEJMT0NLX0VYVEVSTkFMTFlfREVQRU5ERU5UX0ZMQUcpIGNvbnNvbGUubG9nKCcgIElzIGV4dGVybmFsbHkgZGVwZW5kZW50Jyk7XHJcblx0XHRcdFx0XHRcdC8vaWYoY3Vyci52YWx1ZSAmIEJMT0NLX1JFU09MVkVEX09SX0RFUEVOREVOVF9GTEFHKSBjb25zb2xlLmxvZygnICBJcyByZXNvbHZlZCB4cmVmIG9yIGRlcGVuZGVudCBvZiBhbiB4cmVmJyk7XHJcblx0XHRcdFx0XHRcdC8vaWYoY3Vyci52YWx1ZSAmIEJMT0NLX1JFRkVSRU5DRURfWFJFRikgY29uc29sZS5sb2coJyAgVGhpcyBkZWZpbml0aW9uIGlzIGEgcmVmZXJlbmNlZCB4cmVmJyk7XHJcblx0XHRcdFx0XHRcdGJsb2NrLnR5cGUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMDA6XHJcblx0XHRcdFx0XHQvLyBpZ25vcmUgY2xhc3MgbWFya2Vyc1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzMzA6XHJcblx0XHRcdFx0XHRibG9jay5vd25lckhhbmRsZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0XHRpZihjdXJyLnZhbHVlID09ICdFTkRCTEsnKVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGJsb2NrLmVudGl0aWVzID0gcGFyc2VFbnRpdGllcyh0cnVlKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRsb2dVbmhhbmRsZWRHcm91cChjdXJyKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZ3JvdXBJcygwLCAnRU5EQkxLJykpIHtcclxuXHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBibG9jaztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBwYXJzZVRhYmxlc1xyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGluZyB0YWJsZXNcclxuXHQgKi9cclxuXHR2YXIgcGFyc2VUYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB0YWJsZXMgPSB7fTtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHdoaWxlKGN1cnIudmFsdWUgIT09ICdFT0YnKSB7XHJcblx0XHRcdGlmKGdyb3VwSXMoMCwgJ0VORFNFQycpKVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0aWYoZ3JvdXBJcygwLCAnVEFCTEUnKSkge1xyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHJcblx0XHRcdFx0dmFyIHRhYmxlRGVmaW5pdGlvbiA9IHRhYmxlRGVmaW5pdGlvbnNbY3Vyci52YWx1ZV07XHJcblx0XHRcdFx0aWYodGFibGVEZWZpbml0aW9uKSB7XHJcblx0XHRcdFx0XHRsb2cuZGVidWcoY3Vyci52YWx1ZSArICcgVGFibGUgeycpO1xyXG5cdFx0XHRcdFx0dGFibGVzW3RhYmxlRGVmaW5pdGlvbnNbY3Vyci52YWx1ZV0udGFibGVOYW1lXSA9IHBhcnNlVGFibGUoKTtcclxuXHRcdFx0XHRcdGxvZy5kZWJ1ZygnfScpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsb2cuZGVidWcoJ1VuaGFuZGxlZCBUYWJsZSAnICsgY3Vyci52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGVsc2UgaWdub3JlZFxyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHJldHVybiB0YWJsZXM7XHJcblx0fTtcclxuXHJcblx0Y29uc3QgRU5EX09GX1RBQkxFX1ZBTFVFID0gJ0VORFRBQic7XHJcblxyXG5cdHZhciBwYXJzZVRhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGFibGVEZWZpbml0aW9uID0gdGFibGVEZWZpbml0aW9uc1tjdXJyLnZhbHVlXSxcclxuXHRcdFx0dGFibGUgPSB7fSxcclxuXHRcdFx0ZXhwZWN0ZWRDb3VudCA9IDAsXHJcblx0XHRcdGFjdHVhbENvdW50O1xyXG5cclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHdoaWxlKCFncm91cElzKDAsIEVORF9PRl9UQUJMRV9WQUxVRSkpIHtcclxuXHJcblx0XHRcdHN3aXRjaChjdXJyLmNvZGUpIHtcclxuXHRcdFx0XHRjYXNlIDU6XHJcblx0XHRcdFx0XHR0YWJsZS5oYW5kbGUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzMzA6XHJcblx0XHRcdFx0XHR0YWJsZS5vd25lckhhbmRsZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDEwMDpcclxuXHRcdFx0XHRcdGlmKGN1cnIudmFsdWUgPT09ICdBY0RiU3ltYm9sVGFibGUnKSB7XHJcblx0XHRcdFx0XHRcdC8vIGlnbm9yZVxyXG5cdFx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0bG9nVW5oYW5kbGVkR3JvdXAoY3Vycik7XHJcblx0XHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNzA6XHJcblx0XHRcdFx0XHRleHBlY3RlZENvdW50ID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdGlmKGN1cnIudmFsdWUgPT09IHRhYmxlRGVmaW5pdGlvbi5keGZTeW1ib2xOYW1lKSB7XHJcblx0XHRcdFx0XHRcdHRhYmxlW3RhYmxlRGVmaW5pdGlvbi50YWJsZVJlY29yZHNQcm9wZXJ0eV0gPSB0YWJsZURlZmluaXRpb24ucGFyc2VUYWJsZVJlY29yZHMoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGxvZ1VuaGFuZGxlZEdyb3VwKGN1cnIpO1xyXG5cdFx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0bG9nVW5oYW5kbGVkR3JvdXAoY3Vycik7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciB0YWJsZVJlY29yZHMgPSB0YWJsZVt0YWJsZURlZmluaXRpb24udGFibGVSZWNvcmRzUHJvcGVydHldO1xyXG5cdFx0aWYodGFibGVSZWNvcmRzKSB7XHJcblx0XHRcdGlmKHRhYmxlUmVjb3Jkcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpe1xyXG5cdFx0XHRcdGFjdHVhbENvdW50ID0gdGFibGVSZWNvcmRzLmxlbmd0aDtcclxuXHRcdFx0fSBlbHNlIGlmKHR5cGVvZih0YWJsZVJlY29yZHMpID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdGFjdHVhbENvdW50ID0gT2JqZWN0LmtleXModGFibGVSZWNvcmRzKS5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZXhwZWN0ZWRDb3VudCAhPT0gYWN0dWFsQ291bnQpIGxvZy53YXJuKCdQYXJzZWQgJyArIGFjdHVhbENvdW50ICsgJyAnICsgdGFibGVEZWZpbml0aW9uLmR4ZlN5bWJvbE5hbWUgKyAnXFwncyBidXQgZXhwZWN0ZWQgJyArIGV4cGVjdGVkQ291bnQpO1xyXG5cdFx0fVxyXG5cdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0cmV0dXJuIHRhYmxlO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJzZVZpZXdQb3J0UmVjb3JkcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZpZXdQb3J0cyA9IFtdLCAvLyBNdWx0aXBsZSB0YWJsZSBlbnRyaWVzIG1heSBoYXZlIHRoZSBzYW1lIG5hbWUgaW5kaWNhdGluZyBhIG11bHRpcGxlIHZpZXdwb3J0IGNvbmZpZ3VyYXRpb25cclxuXHRcdFx0dmlld1BvcnQgPSB7fTtcclxuXHJcblx0XHRsb2cuZGVidWcoJ1ZpZXdQb3J0IHsnKTtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdHdoaWxlKCFncm91cElzKDAsIEVORF9PRl9UQUJMRV9WQUxVRSkpIHtcclxuXHJcblx0XHRcdHN3aXRjaChjdXJyLmNvZGUpIHtcclxuXHRcdFx0XHRjYXNlIDI6IC8vIGxheWVyIG5hbWVcclxuXHRcdFx0XHRcdHZpZXdQb3J0Lm5hbWUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMDpcclxuXHRcdFx0XHRcdHZpZXdQb3J0Lmxvd2VyTGVmdENvcm5lciA9IHBhcnNlUG9pbnQoKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTE6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC51cHBlclJpZ2h0Q29ybmVyID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMjpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LmNlbnRlciA9IHBhcnNlUG9pbnQoKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTM6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC5zbmFwQmFzZVBvaW50ID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxNDpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LnNuYXBTcGFjaW5nID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxNTpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LmdyaWRTcGFjaW5nID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxNjpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LnZpZXdEaXJlY3Rpb25Gcm9tVGFyZ2V0ID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxNzpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LnZpZXdUYXJnZXQgPSBwYXJzZVBvaW50KCk7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDQyOlxyXG5cdFx0XHRcdFx0dmlld1BvcnQubGVuc0xlbmd0aCA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDQzOlxyXG5cdFx0XHRcdFx0dmlld1BvcnQuZnJvbnRDbGlwcGluZ1BsYW5lID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNDQ6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC5iYWNrQ2xpcHBpbmdQbGFuZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDQ1OlxyXG5cdFx0XHRcdFx0dmlld1BvcnQudmlld0hlaWdodCA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDUwOlxyXG5cdFx0XHRcdFx0dmlld1BvcnQuc25hcFJvdGF0aW9uQW5nbGUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA1MTpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LnZpZXdUd2lzdEFuZ2xlID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OTpcclxuICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydC5vcnRob2dyYXBoaWNUeXBlID0gY3Vyci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMTA6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC51Y3NPcmlnaW4gPSBwYXJzZVBvaW50KCk7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDExMTpcclxuXHRcdFx0XHRcdHZpZXdQb3J0LnVjc1hBeGlzID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMTI6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC51Y3NZQXhpcyA9IHBhcnNlUG9pbnQoKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTEwOlxyXG5cdFx0XHRcdFx0dmlld1BvcnQudWNzT3JpZ2luID0gcGFyc2VQb2ludCgpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAyODE6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC5yZW5kZXJNb2RlID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMjgxOlxyXG5cdFx0XHRcdFx0Ly8gMCBpcyBvbmUgZGlzdGFudCBsaWdodCwgMSBpcyB0d28gZGlzdGFudCBsaWdodHNcclxuXHRcdFx0XHRcdHZpZXdQb3J0LmRlZmF1bHRMaWdodGluZ1R5cGUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAyOTI6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC5kZWZhdWx0TGlnaHRpbmdPbiA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDMzMDpcclxuXHRcdFx0XHRcdHZpZXdQb3J0Lm93bmVySGFuZGxlID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNjM6IC8vIFRoZXNlIGFyZSBhbGwgYW1iaWVudCBjb2xvci4gUGVyaGFwcyBzaG91bGQgYmUgYSBncmFkaWVudCB3aGVuIG11bHRpcGxlIGFyZSBzZXQuXHJcblx0XHRcdFx0Y2FzZSA0MjE6XHJcblx0XHRcdFx0Y2FzZSA0MzE6XHJcblx0XHRcdFx0XHR2aWV3UG9ydC5hbWJpZW50Q29sb3IgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0Ly8gTmV3IFZpZXdQb3J0XHJcblx0XHRcdFx0XHRpZihjdXJyLnZhbHVlID09PSAnVlBPUlQnKSB7XHJcblx0XHRcdFx0XHRcdGxvZy5kZWJ1ZygnfScpO1xyXG5cdFx0XHRcdFx0XHR2aWV3UG9ydHMucHVzaCh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRcdGxvZy5kZWJ1ZygnVmlld1BvcnQgeycpO1xyXG5cdFx0XHRcdFx0XHR2aWV3UG9ydCA9IHt9O1xyXG5cdFx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0bG9nVW5oYW5kbGVkR3JvdXAoY3Vycik7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gTm90ZTogZG8gbm90IGNhbGwgc2Nhbm5lci5uZXh0KCkgaGVyZSxcclxuXHRcdC8vICBwYXJzZVRhYmxlKCkgbmVlZHMgdGhlIGN1cnJlbnQgZ3JvdXBcclxuXHRcdGxvZy5kZWJ1ZygnfScpO1xyXG5cdFx0dmlld1BvcnRzLnB1c2godmlld1BvcnQpO1xyXG5cclxuXHRcdHJldHVybiB2aWV3UG9ydHM7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcnNlTGluZVR5cGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbHR5cGVzID0ge30sXHJcblx0XHRcdGx0eXBlTmFtZSxcclxuXHRcdFx0bHR5cGUgPSB7fSxcclxuXHRcdFx0bGVuZ3RoO1xyXG5cclxuXHRcdGxvZy5kZWJ1ZygnTFR5cGUgeycpO1xyXG5cdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0d2hpbGUoIWdyb3VwSXMoMCwgJ0VORFRBQicpKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2goY3Vyci5jb2RlKSB7XHJcblx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0bHR5cGUubmFtZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRsdHlwZU5hbWUgPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0bHR5cGUuZGVzY3JpcHRpb24gPSBjdXJyLnZhbHVlO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA3MzogLy8gTnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGlzIGxpbmUgdHlwZSAoZG90cywgZGFzaGVzLCBzcGFjZXMpO1xyXG5cdFx0XHRcdFx0bGVuZ3RoID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGlmKGxlbmd0aCA+IDApIGx0eXBlLnBhdHRlcm4gPSBbXTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNDA6IC8vIHRvdGFsIHBhdHRlcm4gbGVuZ3RoXHJcblx0XHRcdFx0XHRsdHlwZS5wYXR0ZXJuTGVuZ3RoID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNDk6XHJcblx0XHRcdFx0XHRsdHlwZS5wYXR0ZXJuLnB1c2goY3Vyci52YWx1ZSk7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0XHRsb2cuZGVidWcoJ30nKTtcclxuXHRcdFx0XHRcdGlmKGxlbmd0aCA+IDAgJiYgbGVuZ3RoICE9PSBsdHlwZS5wYXR0ZXJuLmxlbmd0aCkgbG9nLndhcm4oJ2xlbmd0aHMgZG8gbm90IG1hdGNoIG9uIExUWVBFIHBhdHRlcm4nKTtcclxuXHRcdFx0XHRcdGx0eXBlc1tsdHlwZU5hbWVdID0gbHR5cGU7XHJcblx0XHRcdFx0XHRsdHlwZSA9IHt9O1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCdMVHlwZSB7Jyk7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bG9nLmRlYnVnKCd9Jyk7XHJcblx0XHRsdHlwZXNbbHR5cGVOYW1lXSA9IGx0eXBlO1xyXG5cdFx0cmV0dXJuIGx0eXBlcztcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyc2VMYXllcnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBsYXllcnMgPSB7fSxcclxuXHRcdFx0bGF5ZXJOYW1lLFxyXG5cdFx0XHRsYXllciA9IHt9O1xyXG5cclxuXHRcdGxvZy5kZWJ1ZygnTGF5ZXIgeycpO1xyXG5cdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0d2hpbGUoIWdyb3VwSXMoMCwgJ0VORFRBQicpKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2goY3Vyci5jb2RlKSB7XHJcblx0XHRcdFx0Y2FzZSAyOiAvLyBsYXllciBuYW1lXHJcblx0XHRcdFx0XHRsYXllci5uYW1lID0gY3Vyci52YWx1ZTtcclxuXHRcdFx0XHRcdGxheWVyTmFtZSA9IGN1cnIudmFsdWU7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDYyOiAvLyBjb2xvciwgdmlzaWJpbGl0eVxyXG5cdFx0XHRcdFx0bGF5ZXIudmlzaWJsZSA9IGN1cnIudmFsdWUgPj0gMDtcclxuXHRcdFx0XHRcdC8vIFRPRE8gMCBhbmQgMjU2IGFyZSBCWUJMT0NLIGFuZCBCWUxBWUVSIHJlc3BlY3RpdmVseS4gTmVlZCB0byBoYW5kbGUgdGhlc2UgdmFsdWVzIGZvciBsYXllcnM/LlxyXG5cdFx0XHRcdFx0bGF5ZXIuY29sb3JJbmRleCA9IE1hdGguYWJzKGN1cnIudmFsdWUpO1xyXG5cdFx0XHRcdFx0bGF5ZXIuY29sb3IgPSBnZXRBY2FkQ29sb3IobGF5ZXIuY29sb3JJbmRleCk7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5uZXh0KCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDcwOiAvLyBmcm96ZW4gbGF5ZXJcclxuXHRcdFx0XHRcdGxheWVyLmZyb3plbiA9ICgoY3Vyci52YWx1ZSAmIDEpICE9IDAgfHwgKGN1cnIudmFsdWUgJiAyKSAhPSAwKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdC8vIE5ldyBMYXllclxyXG5cdFx0XHRcdFx0aWYoY3Vyci52YWx1ZSA9PT0gJ0xBWUVSJykge1xyXG5cdFx0XHRcdFx0XHRsb2cuZGVidWcoJ30nKTtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzW2xheWVyTmFtZV0gPSBsYXllcjtcclxuXHRcdFx0XHRcdFx0bG9nLmRlYnVnKCdMYXllciB7Jyk7XHJcblx0XHRcdFx0XHRcdGxheWVyID0ge307XHJcblx0XHRcdFx0XHRcdGxheWVyTmFtZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGxvZ1VuaGFuZGxlZEdyb3VwKGN1cnIpO1xyXG5cdFx0XHRcdFx0Y3VyciA9IHNjYW5uZXIubmV4dCgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vIE5vdGU6IGRvIG5vdCBjYWxsIHNjYW5uZXIubmV4dCgpIGhlcmUsXHJcblx0XHQvLyAgcGFyc2VMYXllclRhYmxlKCkgbmVlZHMgdGhlIGN1cnJlbnQgZ3JvdXBcclxuXHRcdGxvZy5kZWJ1ZygnfScpO1xyXG5cdFx0bGF5ZXJzW2xheWVyTmFtZV0gPSBsYXllcjtcclxuXHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH07XHJcblxyXG5cdHZhciB0YWJsZURlZmluaXRpb25zID0ge1xyXG5cdFx0VlBPUlQ6IHtcclxuXHRcdFx0dGFibGVSZWNvcmRzUHJvcGVydHk6ICd2aWV3UG9ydHMnLFxyXG5cdFx0XHR0YWJsZU5hbWU6ICd2aWV3UG9ydCcsXHJcblx0XHRcdGR4ZlN5bWJvbE5hbWU6ICdWUE9SVCcsXHJcblx0XHRcdHBhcnNlVGFibGVSZWNvcmRzOiBwYXJzZVZpZXdQb3J0UmVjb3Jkc1xyXG5cdFx0fSxcclxuXHRcdExUWVBFOiB7XHJcblx0XHRcdHRhYmxlUmVjb3Jkc1Byb3BlcnR5OiAnbGluZVR5cGVzJyxcclxuXHRcdFx0dGFibGVOYW1lOiAnbGluZVR5cGUnLFxyXG5cdFx0XHRkeGZTeW1ib2xOYW1lOiAnTFRZUEUnLFxyXG5cdFx0XHRwYXJzZVRhYmxlUmVjb3JkczogcGFyc2VMaW5lVHlwZXNcclxuXHRcdH0sXHJcblx0XHRMQVlFUjoge1xyXG5cdFx0XHR0YWJsZVJlY29yZHNQcm9wZXJ0eTogJ2xheWVycycsXHJcblx0XHRcdHRhYmxlTmFtZTogJ2xheWVyJyxcclxuXHRcdFx0ZHhmU3ltYm9sTmFtZTogJ0xBWUVSJyxcclxuXHRcdFx0cGFyc2VUYWJsZVJlY29yZHM6IHBhcnNlTGF5ZXJzXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSXMgY2FsbGVkIGFmdGVyIHRoZSBwYXJzZXIgZmlyc3QgcmVhZHMgdGhlIDA6RU5USVRJRVMgZ3JvdXAuIFRoZSBzY2FubmVyXHJcblx0ICogc2hvdWxkIGJlIG9uIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgZW50aXR5IGFscmVhZHkuXHJcblx0ICogQHJldHVybiB7QXJyYXl9IHRoZSByZXN1bHRpbmcgZW50aXRpZXNcclxuXHQgKi9cclxuXHR2YXIgcGFyc2VFbnRpdGllcyA9IGZ1bmN0aW9uKGZvckJsb2NrKSB7XHJcblx0XHR2YXIgZW50aXRpZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgZW5kaW5nT25WYWx1ZSA9IGZvckJsb2NrID8gJ0VOREJMSycgOiAnRU5EU0VDJztcclxuXHJcblx0XHRpZiAoIWZvckJsb2NrKSB7XHJcblx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdH1cclxuXHRcdHdoaWxlKHRydWUpIHtcclxuXHJcblx0XHRcdGlmKGN1cnIuY29kZSA9PT0gMCkge1xyXG5cdFx0XHRcdGlmKGN1cnIudmFsdWUgPT09IGVuZGluZ09uVmFsdWUpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGVudGl0eTtcclxuXHRcdFx0XHR2YXIgaGFuZGxlciA9IHNlbGYuX2VudGl0eUhhbmRsZXJzW2N1cnIudmFsdWVdO1xyXG5cdFx0XHRcdGlmKGhhbmRsZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKGN1cnIudmFsdWUgKyAnIHsnKTtcclxuXHRcdFx0XHRcdGVudGl0eSA9IGhhbmRsZXIucGFyc2VFbnRpdHkoc2Nhbm5lciwgY3Vycik7XHJcblx0XHRcdFx0XHRjdXJyID0gc2Nhbm5lci5sYXN0UmVhZEdyb3VwO1xyXG5cdFx0XHRcdFx0bG9nLmRlYnVnKCd9Jyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxvZy53YXJuKCdVbmhhbmRsZWQgZW50aXR5ICcgKyBjdXJyLnZhbHVlKTtcclxuXHRcdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbnN1cmVIYW5kbGUoZW50aXR5KTtcclxuXHRcdFx0XHRlbnRpdGllcy5wdXNoKGVudGl0eSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gaWdub3JlZCBsaW5lcyBmcm9tIHVuc3VwcG9ydGVkIGVudGl0eVxyXG5cdFx0XHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYoZW5kaW5nT25WYWx1ZSA9PSAnRU5EU0VDJykgY3VyciA9IHNjYW5uZXIubmV4dCgpOyAvLyBzd2FsbG93IHVwIEVORFNFQywgYnV0IG5vdCBFTkRCTEtcclxuXHRcdHJldHVybiBlbnRpdGllcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQYXJzZXMgYSAyRCBvciAzRCBwb2ludCwgcmV0dXJuaW5nIGl0IGFzIGFuIG9iamVjdCB3aXRoIHgsIHksIGFuZFxyXG5cdCAqIChzb21ldGltZXMpIHogcHJvcGVydHkgaWYgaXQgaXMgM0QuIEl0IGlzIGFzc3VtZWQgdGhlIGN1cnJlbnQgZ3JvdXBcclxuXHQgKiBpcyB4IG9mIHRoZSBwb2ludCBiZWluZyByZWFkIGluLCBhbmQgc2Nhbm5lci5uZXh0KCkgd2lsbCByZXR1cm4gdGhlXHJcblx0ICogeS4gVGhlIHBhcnNlciB3aWxsIGRldGVybWluZSBpZiB0aGVyZSBpcyBhIHogcG9pbnQgYXV0b21hdGljYWxseS5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSAyRCBvciAzRCBwb2ludCBhcyBhbiBvYmplY3Qgd2l0aCB4LCB5Wywgel1cclxuXHQgKi9cclxuXHR2YXIgcGFyc2VQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBvaW50ID0ge30sXHJcblx0XHRcdGNvZGUgPSBjdXJyLmNvZGU7XHJcblxyXG5cdFx0cG9pbnQueCA9IGN1cnIudmFsdWU7XHJcblxyXG5cdFx0Y29kZSArPSAxMDtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdGlmKGN1cnIuY29kZSAhPSBjb2RlKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvZGUgZm9yIHBvaW50IHZhbHVlIHRvIGJlICcgKyBjb2RlICtcclxuXHRcdFx0JyBidXQgZ290ICcgKyBjdXJyLmNvZGUgKyAnLicpO1xyXG5cdFx0cG9pbnQueSA9IGN1cnIudmFsdWU7XHJcblxyXG5cdFx0Y29kZSArPSAxMDtcclxuXHRcdGN1cnIgPSBzY2FubmVyLm5leHQoKTtcclxuXHRcdGlmKGN1cnIuY29kZSAhPSBjb2RlKVxyXG5cdFx0e1xyXG5cdFx0XHRzY2FubmVyLnJld2luZCgpO1xyXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0XHR9XHJcblx0XHRwb2ludC56ID0gY3Vyci52YWx1ZTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH07XHJcblxyXG5cdHZhciBlbnN1cmVIYW5kbGUgPSBmdW5jdGlvbihlbnRpdHkpIHtcclxuXHRcdGlmKCFlbnRpdHkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VudGl0eSBjYW5ub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwnKTtcclxuXHJcblx0XHRpZighZW50aXR5LmhhbmRsZSkgZW50aXR5LmhhbmRsZSA9IGxhc3RIYW5kbGUrKztcclxuXHR9O1xyXG5cclxuXHRwYXJzZUFsbCgpO1xyXG5cdHJldHVybiBkeGY7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBsb2dVbmhhbmRsZWRHcm91cChjdXJyKSB7XHJcblx0bG9nLmRlYnVnKCd1bmhhbmRsZWQgZ3JvdXAgJyArIGRlYnVnQ29kZShjdXJyKSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkZWJ1Z0NvZGUoY3Vycikge1xyXG5cdHJldHVybiBjdXJyLmNvZGUgKyAnOicgKyBjdXJyLnZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdHJ1ZWNvbG9yIHZhbHVlIG9mIHRoZSBnaXZlbiBBdXRvQ2FkIGNvbG9yIGluZGV4IHZhbHVlXHJcbiAqIEByZXR1cm4ge051bWJlcn0gdHJ1ZWNvbG9yIHZhbHVlIGFzIGEgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBY2FkQ29sb3IoaW5kZXgpIHtcclxuXHRyZXR1cm4gQVVUT19DQURfQ09MT1JfSU5ERVhbaW5kZXhdO1xyXG59XHJcblxyXG5jb25zdCBCTE9DS19BTk9OWU1PVVNfRkxBRyA9IDE7XHJcbmNvbnN0IEJMT0NLX05PTl9DT05TVEFOVF9GTEFHID0gMjtcclxuY29uc3QgQkxPQ0tfWFJFRl9GTEFHID0gNDtcclxuY29uc3QgQkxPQ0tfWFJFRl9PVkVSTEFZX0ZMQUcgPSA4O1xyXG5jb25zdCBCTE9DS19FWFRFUk5BTExZX0RFUEVOREVOVF9GTEFHID0gMTY7XHJcbmNvbnN0IEJMT0NLX1JFU09MVkVEX09SX0RFUEVOREVOVF9GTEFHID0gMzI7XHJcbmNvbnN0IEJMT0NLX1JFRkVSRU5DRURfWFJFRiA9IDY0O1xyXG5cclxuXHJcbi8qIE5vdGVzICovXHJcbi8vIENvZGUgNiBvZiBhbiBlbnRpdHkgaW5kaWNhdGVzIGluaGVyaXRhbmNlIG9mIHByb3BlcnRpZXMgKGVnLiBjb2xvcikuXHJcbi8vICAgQllCTE9DSyBtZWFucyBpbmhlcml0cyBmcm9tIGJsb2NrXHJcbi8vICAgQllMQVlFUiAoZGVmYXVsdCkgbWVhbiBpbmhlcml0cyBmcm9tIGxheWVyXHJcbiIsImltcG9ydCBEeGZQYXJzZXIgZnJvbSAnLi9EeGZQYXJzZXIuanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHhmUGFyc2VyOyIsIi8qKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAqL1xuLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xuLy8gdGhlIFwidXBcIiBkaXJlY3Rpb24gYXMgK1ksIHVubGlrZSB0aGUgVHJhY2tiYWxsQ29udHJvbHMuIFRvdWNoIG9uIHRhYmxldCBhbmQgcGhvbmVzIGlzXG4vLyBzdXBwb3J0ZWQuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxuLy9cbi8vIFRoaXMgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciAobW9zdCkgVHJhY2tiYWxsQ29udHJvbHMgdXNlZCBpbiBleGFtcGxlcy5cbi8vIFRoYXQgaXMsIGluY2x1ZGUgdGhpcyBqcyBmaWxlIGFuZCB3aGVyZXZlciB5b3Ugc2VlOlxuLy8gICAgXHRjb250cm9scyA9IG5ldyBUSFJFRS5UcmFja2JhbGxDb250cm9scyggY2FtZXJhICk7XG4vLyAgICAgIGNvbnRyb2xzLnRhcmdldC56ID0gMTUwO1xuLy8gU2ltcGxlIHN1YnN0aXR1dGUgXCJPcmJpdENvbnRyb2xzXCIgYW5kIHRoZSBjb250cm9sIHNob3VsZCB3b3JrIGFzLWlzLlxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBPcmJpdENvbnRyb2xzKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0Ly8gQVBJXG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0Ly8gXCJ0YXJnZXRcIiBzZXRzIHRoZSBsb2NhdGlvbiBvZiBmb2N1cywgd2hlcmUgdGhlIGNvbnRyb2wgb3JiaXRzIGFyb3VuZFxuXHQvLyBhbmQgd2hlcmUgaXQgcGFucyB3aXRoIHJlc3BlY3QgdG8uXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHQvLyBjZW50ZXIgaXMgb2xkLCBkZXByZWNhdGVkOyB1c2UgXCJ0YXJnZXRcIiBpbnN0ZWFkXG5cdHRoaXMuY2VudGVyID0gdGhpcy50YXJnZXQ7XG5cblx0Ly8gVGhpcyBvcHRpb24gYWN0dWFsbHkgZW5hYmxlcyBkb2xseWluZyBpbiBhbmQgb3V0OyBsZWZ0IGFzIFwiem9vbVwiIGZvclxuXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHR0aGlzLm5vWm9vbSA9IGZhbHNlO1xuXHR0aGlzLnpvb21TcGVlZCA9IDEuMDtcblxuXHQvLyBMaW1pdHMgdG8gaG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXRcblx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHR0aGlzLm5vUm90YXRlID0gZmFsc2U7XG5cdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcblx0dGhpcy5ub1BhbiA9IGZhbHNlO1xuXHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG5cdC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG5cdHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXG5cdC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG5cdHRoaXMubm9LZXlzID0gZmFsc2U7XG5cblx0Ly8gVGhlIGZvdXIgYXJyb3cga2V5c1xuXHR0aGlzLmtleXMgPSB7IExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgQk9UVE9NOiA0MCB9O1xuXG5cdC8vLy8vLy8vLy8vL1xuXHQvLyBpbnRlcm5hbHNcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHR2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbkRlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIGRvbGx5U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmFyIHBoaURlbHRhID0gMDtcblx0dmFyIHRoZXRhRGVsdGEgPSAwO1xuXHR2YXIgc2NhbGUgPSAxO1xuXHR2YXIgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgbGFzdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgU1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgRE9MTFkgOiAxLCBQQU4gOiAyLCBUT1VDSF9ST1RBVEUgOiAzLCBUT1VDSF9ET0xMWSA6IDQsIFRPVUNIX1BBTiA6IDUgfTtcblxuXHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdC8vIGZvciByZXNldFxuXG5cdHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG5cdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblxuXHQvLyBldmVudHNcblxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5cdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnfTtcblx0dmFyIGVuZEV2ZW50ID0geyB0eXBlOiAnZW5kJ307XG5cblx0dGhpcy5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhldGFEZWx0YSAtPSBhbmdsZTtcblxuXHR9O1xuXG5cdHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cblx0XHR9XG5cblx0XHRwaGlEZWx0YSAtPSBhbmdsZTtcblxuXHR9O1xuXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSBsZWZ0XG5cdHRoaXMucGFuTGVmdCA9IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XG5cblx0XHQvLyBnZXQgWCBjb2x1bW4gb2YgbWF0cml4XG5cdFx0cGFuT2Zmc2V0LnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xuXHRcdHBhbk9mZnNldC5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSApO1xuXHRcdFxuXHRcdHBhbi5hZGQoIHBhbk9mZnNldCApO1xuXG5cdH07XG5cblx0Ly8gcGFzcyBpbiBkaXN0YW5jZSBpbiB3b3JsZCBzcGFjZSB0byBtb3ZlIHVwXG5cdHRoaXMucGFuVXAgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Ly8gZ2V0IFkgY29sdW1uIG9mIG1hdHJpeFxuXHRcdHBhbk9mZnNldC5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKTtcblx0XHRwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICk7XG5cdFx0XG5cdFx0cGFuLmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0fTtcblx0XG5cdC8vIHBhc3MgaW4geCx5IG9mIGNoYW5nZSBkZXNpcmVkIGluIHBpeGVsIHNwYWNlLFxuXHQvLyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0dGhpcy5wYW4gPSBmdW5jdGlvbiAoIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRpZiAoIHNjb3BlLm9iamVjdC5mb3YgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gcGVyc3BlY3RpdmVcblx0XHRcdHZhciBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcblx0XHRcdHZhciBvZmZzZXQgPSBwb3NpdGlvbi5jbG9uZSgpLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHR2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cblx0XHRcdC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxuXHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHQvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG5cdFx0XHRzY29wZS5wYW5MZWZ0KCAyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xuXHRcdFx0c2NvcGUucGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QudG9wICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBcblx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xuXHRcdFx0c2NvcGUucGFuTGVmdCggZGVsdGFYICogKHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0KSAvIGVsZW1lbnQuY2xpZW50V2lkdGggKTtcblx0XHRcdHNjb3BlLnBhblVwKCBkZWx0YVkgKiAoc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20pIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBvciBwZXJzcGVjdGl2ZVxuXHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZG9sbHlJbiA9IGZ1bmN0aW9uICggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XG5cblx0XHR9XG5cblx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdH07XG5cblx0dGhpcy5kb2xseU91dCA9IGZ1bmN0aW9uICggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XG5cblx0XHR9XG5cblx0XHRzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFxuICAgICAgICBpZihzY29wZS5vYmplY3QudG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LnRvcCA9IChzY2FsZSp0aGlzLm9iamVjdC50b3ApO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QuYm90dG9tID0gKHNjYWxlKnRoaXMub2JqZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5sZWZ0ID0gKHNjYWxlKnRoaXMub2JqZWN0LmxlZnQpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QucmlnaHQgPSAoc2NhbGUqdGhpcy5vYmplY3QucmlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICAgICAgfVxuICAgICAgICAgICAgXG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcblxuXHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1YiggdGhpcy50YXJnZXQgKTtcbi8vXG4vL1x0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG4vL1xuLy9cdFx0dmFyIHRoZXRhID0gTWF0aC5hdGFuMiggb2Zmc2V0LngsIG9mZnNldC56ICk7XG4vL1xuLy9cdFx0Ly8gYW5nbGUgZnJvbSB5LWF4aXNcbi8vXG4vL1x0XHR2YXIgcGhpID0gTWF0aC5hdGFuMiggTWF0aC5zcXJ0KCBvZmZzZXQueCAqIG9mZnNldC54ICsgb2Zmc2V0LnogKiBvZmZzZXQueiApLCBvZmZzZXQueSApO1xuLy9cbi8vXHRcdGlmICggdGhpcy5hdXRvUm90YXRlICkge1xuLy9cbi8vXHRcdFx0dGhpcy5yb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG4vL1xuLy9cdFx0fVxuLy9cbi8vXHRcdHRoZXRhICs9IHRoZXRhRGVsdGE7XG4vL1x0XHRwaGkgKz0gcGhpRGVsdGE7XG4vL1xuLy9cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcbi8vXHRcdHBoaSA9IE1hdGgubWF4KCB0aGlzLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCB0aGlzLm1heFBvbGFyQW5nbGUsIHBoaSApICk7XG4vL1xuLy9cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuLy9cdFx0cGhpID0gTWF0aC5tYXgoIEVQUywgTWF0aC5taW4oIE1hdGguUEkgLSBFUFMsIHBoaSApICk7XG4vL1xuLy9cdFx0dmFyIHJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKSAqIHNjYWxlO1xuLy9cbi8vXHRcdC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4vL1x0XHRyYWRpdXMgPSBNYXRoLm1heCggdGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cyApICk7XG4vL1x0XHRcbi8vXHRcdC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuXHRcdHRoaXMudGFyZ2V0LmFkZCggcGFuICk7XG4vL1x0XHRcbi8vXHRcdG9mZnNldC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5zaW4oIHRoZXRhICk7XG4vL1x0XHRvZmZzZXQueSA9IHJhZGl1cyAqIE1hdGguY29zKCBwaGkgKTtcbi8vXHRcdG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XG4vL1xuXHRcdHBvc2l0aW9uLmNvcHkoIHRoaXMudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuXHRcdHRoaXMub2JqZWN0Lmxvb2tBdCggdGhpcy50YXJnZXQgKTtcblxuXG4vL1x0XHRpZiAoIGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvKCB0aGlzLm9iamVjdC5wb3NpdGlvbiApID4gMCB8fCBzY2FsZSAhPT0gMSApIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xuXG4vL1x0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXG4vL1x0XHR9XG4gICAgICAgIFxuLy8gICAgICAgIHRoZXRhRGVsdGEgPSAwO1xuLy9cdFx0cGhpRGVsdGEgPSAwO1xuXHRcdHNjYWxlID0gMTtcblx0XHRwYW4uc2V0KCAwLCAwLCAwICk7XG5cblx0fTtcblxuXG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR0aGlzLnRhcmdldC5jb3B5KCB0aGlzLnRhcmdldDAgKTtcblx0XHR0aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLnBvc2l0aW9uMCApO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZURvd24oIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKCBldmVudC5idXR0b24gPT09IDAgKSB7XG5cdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDEgKSB7XG5cdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcblxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMiApIHtcblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0aWYgKCBzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcblx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLkRPTExZICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0XHRzY29wZS5kb2xseUluKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2NvcGUuZG9sbHlPdXQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuUEFOICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cdFx0XHRcblx0XHRcdHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdH1cblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlVXAoIC8qIGV2ZW50ICovICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR2YXIgZGVsdGEgPSAwO1xuXG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICE9PSB1bmRlZmluZWQgKSB7IC8vIFdlYktpdCAvIE9wZXJhIC8gRXhwbG9yZXIgOVxuXG5cdFx0XHRkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGE7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZXRhaWwgIT09IHVuZGVmaW5lZCApIHsgLy8gRmlyZWZveFxuXG5cdFx0XHRkZWx0YSA9IC0gZXZlbnQuZGV0YWlsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkZWx0YSA+IDAgKSB7XG5cblx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzY29wZS5kb2xseUluKCk7XG5cblx0XHR9XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXHRcdFxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5VUDpcblx0XHRcdFx0c2NvcGUucGFuKCAwLCBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XG5cdFx0XHRcdHNjb3BlLnBhbiggMCwgLSBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuXHRcdFx0XHRzY29wZS5wYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXHRcdFx0XHRzY29wZS5wYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0b3VjaHN0YXJ0KCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMjpcdC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZO1xuXG5cdFx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cdFx0XHRcdGRvbGx5U3RhcnQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdG91Y2htb3ZlKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1JPVEFURSApIHJldHVybjtcblxuXHRcdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXHRcdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdFx0XHRzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcblx0XHRcdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG5cdFx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDI6IC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkgKSByZXR1cm47XG5cblx0XHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xuXHRcdFx0XHR2YXIgZHkgPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVk7XG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdFx0XHRkb2xseUVuZC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cdFx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5kb2xseU91dCgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzY29wZS5kb2xseUluKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG5cdFx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjtcblxuXHRcdFx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXHRcdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuXHRcdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0b3VjaGVuZCggLyogZXZlbnQgKi8gKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fVxuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcblxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSApO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxufTtcblxuT3JiaXRDb250cm9scy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7IiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IER4ZlBhcnNlciBmcm9tICdkeGYtcGFyc2VyJztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICcuL09yYml0Q29udHJvbHMnO1xuXG4vLyBUaHJlZS5qcyBleHRlbnNpb24gZnVuY3Rpb25zLiBXZWJwYWNrIGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0IGlmIHdlIG1vZGlmeSB0aGUgVEhSRUUgb2JqZWN0IGRpcmVjdGx5LlxudmFyIFRIUkVFeCA9IHsgTWF0aDoge30gfTtcbi8qKlxuICogUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucyBvZiB0aGUgdmVjdG9yIChwMSxwMikuIEluIG90aGVyIHdvcmRzLCBpbWFnaW5lXG4gKiBwdXR0aW5nIHRoZSBiYXNlIG9mIHRoZSB2ZWN0b3IgYXQgY29vcmRpbmF0ZXMgKDAsMCkgYW5kIGZpbmRpbmcgdGhlIGFuZ2xlXG4gKiBmcm9tIHZlY3RvciAoMSwwKSB0byAocDEscDIpLlxuICogQHBhcmFtICB7T2JqZWN0fSBwMSBzdGFydCBwb2ludCBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0gIHtPYmplY3R9IHAyIGVuZCBwb2ludCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbmdsZVxuICovXG5USFJFRXguTWF0aC5hbmdsZTIgPSBmdW5jdGlvbihwMSwgcDIpIHtcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIocDEueCwgcDEueSk7XG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKHAyLngsIHAyLnkpO1xuXHR2Mi5zdWIodjEpOyAvLyBzZXRzIHYyIHRvIGJlIG91ciBjaG9yZFxuXHR2Mi5ub3JtYWxpemUoKTtcblx0aWYodjIueSA8IDApIHJldHVybiAtTWF0aC5hY29zKHYyLngpO1xuXHRyZXR1cm4gTWF0aC5hY29zKHYyLngpO1xufTtcblxuXG5USFJFRXguTWF0aC5wb2xhciA9IGZ1bmN0aW9uKHBvaW50LCBkaXN0YW5jZSwgYW5nbGUpIHtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRyZXN1bHQueCA9IHBvaW50LnggKyBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcblx0cmVzdWx0LnkgPSBwb2ludC55ICsgZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgcG9pbnRzIGZvciBhIGN1cnZlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHN0YXJ0UG9pbnQgLSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGN1cnZlXG4gKiBAcGFyYW0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICogQHBhcmFtIGJ1bGdlIC0gYSB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBtdWNoIHRvIGN1cnZlXG4gKiBAcGFyYW0gc2VnbWVudHMgLSBudW1iZXIgb2Ygc2VnbWVudHMgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvaW50c1xuICovXG5USFJFRXguQnVsZ2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlLCBzZWdtZW50cyApIHtcblxuXHR2YXIgdmVydGV4LCBpLFxuXHRcdGNlbnRlciwgcDAsIHAxLCBhbmdsZSxcblx0XHRyYWRpdXMsIHN0YXJ0QW5nbGUsXG5cdFx0dGhldGFBbmdsZTtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5zdGFydFBvaW50ID0gcDAgPSBzdGFydFBvaW50ID8gbmV3IFRIUkVFLlZlY3RvcjIoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMCwwKTtcblx0dGhpcy5lbmRQb2ludCA9IHAxID0gZW5kUG9pbnQgPyBuZXcgVEhSRUUuVmVjdG9yMihlbmRQb2ludC54LCBlbmRQb2ludC55KSA6IG5ldyBUSFJFRS5WZWN0b3IyKDEsMCk7XG5cdHRoaXMuYnVsZ2UgPSBidWxnZSA9IGJ1bGdlIHx8IDE7XG5cblx0YW5nbGUgPSA0ICogTWF0aC5hdGFuKGJ1bGdlKTtcblx0cmFkaXVzID0gcDAuZGlzdGFuY2VUbyhwMSkgLyAyIC8gTWF0aC5zaW4oYW5nbGUvMik7XG5cdGNlbnRlciA9IFRIUkVFeC5NYXRoLnBvbGFyKHN0YXJ0UG9pbnQsIHJhZGl1cywgVEhSRUV4Lk1hdGguYW5nbGUyKHAwLHAxKSArIChNYXRoLlBJIC8gMiAtIGFuZ2xlLzIpKTtcblxuXHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHMgPSBzZWdtZW50cyB8fCBNYXRoLm1heCggTWF0aC5hYnMoTWF0aC5jZWlsKGFuZ2xlLyhNYXRoLlBJLzE4KSkpLCA2KTsgLy8gQnkgZGVmYXVsdCB3YW50IGEgc2VnbWVudCByb3VnaGx5IGV2ZXJ5IDEwIGRlZ3JlZXNcblx0c3RhcnRBbmdsZSA9IFRIUkVFeC5NYXRoLmFuZ2xlMihjZW50ZXIsIHAwKTtcblx0dGhldGFBbmdsZSA9IGFuZ2xlIC8gc2VnbWVudHM7XG5cblxuXHR0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMocDAueCwgcDAueSwgMCkpO1xuXG5cdGZvcihpID0gMTsgaSA8PSBzZWdtZW50cyAtIDE7IGkrKykge1xuXG5cdFx0dmVydGV4ID0gVEhSRUV4Lk1hdGgucG9sYXIoY2VudGVyLCBNYXRoLmFicyhyYWRpdXMpLCBzdGFydEFuZ2xlICsgdGhldGFBbmdsZSAqIGkpO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRleC54LCB2ZXJ0ZXgueSwgMCkpO1xuXG5cdH1cblxufTtcblxuVEhSRUV4LkJ1bGdlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8qKlxuICogVEhSRUUuTG9hZGVyIGltcGxlbWVudGF0aW9uIGZvciBEWEYgZmlsZXNcbiAqIFxuICogQHBhcmFtIHsqfSBtYW5hZ2VyIFRIUkVFLkxvYWRpbmdNYW5hZ2VyIFxuICogXG4gKiBAc2VlIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2xvYWRlcnMvTG9hZGVyXG4gKiBAYXV0aG9yIFNvdXJhYmggU29uaSAvIGh0dHBzOi8vd3d3LnByb2xpbmN1ci5jb21cbiAqL1xuZXhwb3J0IGNvbnN0IERYRkxvYWRlciA9IGZ1bmN0aW9uIChtYW5hZ2VyKSB7XG4gICAgTG9hZGVyLmNhbGwodGhpcywgbWFuYWdlcik7XG4gICAgdGhpcy5mb250ID0gbnVsbFxufVxuXG5EWEZMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyLnByb3RvdHlwZSApLCB7XG4gICAgY29uc3RydWN0b3I6IERYRkxvYWRlcixcblxuICAgIHNldEZvbnQ6IGZ1bmN0aW9uICggZm9udCApIHtcblx0XHR0aGlzLmZvbnQgPSBmb250O1xuXHRcdHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblxuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgKCB0ZXh0ICkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoc2NvcGUucGFyc2UodGV4dCkpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKVxuICAgICAgICAgICAgfVxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRHhmUGFyc2VyKCk7XG4gICAgICAgIHZhciBkeGYgPSBwYXJzZXIucGFyc2VTeW5jKHRleHQpXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRFbnRpdGllcyhkeGYsIHRoaXMuZm9udClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYnVmZmVyIC0gdGhlIGR4ZiBmaWxlIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9udCAtIGEgZm9udCBsb2FkZWQgd2l0aCBUSFJFRS5Gb250TG9hZGVyIFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGxvYWRFbnRpdGllczogZnVuY3Rpb24gKCBkYXRhLCBmb250ICkge1xuXG4gICAgICAgIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKTtcblxuICAgICAgICB2YXIgZW50aXRpZXMgPSBbXVxuXG4gICAgICAgIC8vIENyZWF0ZSBzY2VuZSBmcm9tIGR4ZiBvYmplY3QgKGRhdGEpXG4gICAgICAgIHZhciBpLCBlbnRpdHksIG9iaiwgbWluX3gsIG1pbl95LCBtaW5feiwgbWF4X3gsIG1heF95LCBtYXhfejtcbiAgICAgICAgdmFyIGRpbXMgPSB7XG4gICAgICAgICAgICBtaW46IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZX0sXG4gICAgICAgICAgICBtYXg6IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZX1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YS5lbnRpdGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW50aXR5ID0gZGF0YS5lbnRpdGllc1tpXTtcbiAgICAgICAgICAgIG9iaiA9IGRyYXdFbnRpdHkoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXMucHVzaChvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnRpdGllczogZW50aXRpZXMsXG4gICAgICAgICAgICBkeGY6IGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdFbnRpdHkoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWVzaDtcbiAgICAgICAgICAgIGlmKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0FSQycpIHtcbiAgICAgICAgICAgICAgICBtZXNoID0gZHJhd0FyYyhlbnRpdHksIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnTFdQT0xZTElORScgfHwgZW50aXR5LnR5cGUgPT09ICdMSU5FJyB8fCBlbnRpdHkudHlwZSA9PT0gJ1BPTFlMSU5FJykge1xuICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3TGluZShlbnRpdHksIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgICAgICAgICBtZXNoID0gZHJhd1RleHQoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1NPTElEJykge1xuICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3U29saWQoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1BPSU5UJykge1xuICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3UG9pbnQoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ0lOU0VSVCcpIHtcbiAgICAgICAgICAgICAgICBtZXNoID0gZHJhd0Jsb2NrKGVudGl0eSwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdTUExJTkUnKSB7XG4gICAgICAgICAgICAgICAgbWVzaCA9IGRyYXdTcGxpbmUoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ01URVhUJykge1xuICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3TXRleHQoZW50aXR5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ0VMTElQU0UnKSB7XG4gICAgICAgICAgICAgICAgbWVzaCA9IGRyYXdFbGxpcHNlKGVudGl0eSwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdESU1FTlNJT04nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbVR5cGVFbnVtID0gZW50aXR5LmRpbWVuc2lvblR5cGUgJiA3O1xuICAgICAgICAgICAgICAgIGlmKGRpbVR5cGVFbnVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3RGltZW5zaW9uKGVudGl0eSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbnN1cHBvcnRlZCBEaW1lbnNpb24gdHlwZTogXCIgKyBkaW1UeXBlRW51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbnN1cHBvcnRlZCBFbnRpdHkgVHlwZTogXCIgKyBlbnRpdHkudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdFbGxpcHNlKGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcblxuICAgICAgICAgICAgdmFyIHhyYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LngsMikgKyBNYXRoLnBvdyhlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSwyKSk7XG4gICAgICAgICAgICB2YXIgeXJhZCA9IHhyYWQqZW50aXR5LmF4aXNSYXRpbztcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIoZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LnksIGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC54KTtcblxuICAgICAgICAgICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZShcbiAgICAgICAgICAgICAgICBlbnRpdHkuY2VudGVyLngsICBlbnRpdHkuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgeHJhZCwgeXJhZCxcbiAgICAgICAgICAgICAgICBlbnRpdHkuc3RhcnRBbmdsZSwgZW50aXR5LmVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgIGZhbHNlLCAvLyBBbHdheXMgY291bnRlcmNsb2Nrd2lzZVxuICAgICAgICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCA1MCApO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgIGxpbmV3aWR0aDogMSwgY29sb3IgOiBjb2xvciB9ICk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb2JqZWN0IHRvIGFkZCB0byB0aGUgc2NlbmVcbiAgICAgICAgICAgIHZhciBlbGxpcHNlID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3TXRleHQoZW50aXR5LCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KCBlbnRpdHkudGV4dCwge1xuICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgc2l6ZTogZW50aXR5LmhlaWdodCAqICg0LzUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtjb2xvcjogY29sb3J9ICk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgLy8gTWVhc3VyZSB3aGF0IHdlIHJlbmRlcmVkLlxuICAgICAgICAgICAgdmFyIG1lYXN1cmUgPSBuZXcgVEhSRUUuQm94MygpO1xuICAgICAgICAgICAgbWVhc3VyZS5zZXRGcm9tT2JqZWN0KCB0ZXh0ICk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0V2lkdGggID0gbWVhc3VyZS5tYXgueCAtIG1lYXN1cmUubWluLng7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0ZXh0IGVuZHMgdXAgYmVpbmcgd2lkZXIgdGhhbiB0aGUgYm94LCBpdCdzIHN1cHBvc2VkXG4gICAgICAgICAgICAvLyB0byBiZSBtdWx0aWxpbmUuIERvaW5nIHRoYXQgaW4gdGhyZWVKUyBpcyBvdmVya2lsbC5cbiAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPiBlbnRpdHkud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbid0IHJlbmRlciB0aGlzIG11bHRpcGxpbmUgTVRFWFQgZW50aXR5LCBzb3JyeS5cIiwgZW50aXR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnogPSAwO1xuICAgICAgICAgICAgc3dpdGNoIChlbnRpdHkuYXR0YWNobWVudFBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3AgTGVmdFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9wIENlbnRlclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aC8yO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3AgUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTWlkZGxlIExlZnRcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodC8yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgLy8gTWlkZGxlIENlbnRlclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aC8yO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQvMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBSaWdodFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0LzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAgICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBDZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAvLyBCb3R0b20gUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1NwbGluZShlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBlbnRpdHkuY29udHJvbFBvaW50cy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHZlYy54LCB2ZWMueSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlZFBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGN1cnZlO1xuICAgICAgICAgICAgaWYgKGVudGl0eS5kZWdyZWVPZlNwbGluZUN1cnZlID09PSAyIHx8IGVudGl0eS5kZWdyZWVPZlNwbGluZUN1cnZlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSArIDIgPCBwb2ludHMubGVuZ3RoOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuZGVncmVlT2ZTcGxpbmVDdXJ2ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgcG9pbnRzW2kgKyAyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHBvaW50c1tpICsgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRQb2ludHMucHVzaC5hcHBseShpbnRlcnBvbGF0ZWRQb2ludHMsIGN1cnZlLmdldFBvaW50cyg1MCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUocG9pbnRzKTtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRQb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDEwMCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBpbnRlcnBvbGF0ZWRQb2ludHMgKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xuICAgICAgICAgICAgdmFyIHNwbGluZU9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNwbGluZU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdMaW5lKGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXG4gICAgICAgICAgICAgICAgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLCBsaW5lVHlwZSwgdmVydGV4LCBzdGFydFBvaW50LCBlbmRQb2ludCwgYnVsZ2VHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICBidWxnZSwgaSwgbGluZTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGdlb21ldHJ5XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBlbnRpdHkudmVydGljZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGlmKGVudGl0eS52ZXJ0aWNlc1tpXS5idWxnZSkge1xuICAgICAgICAgICAgICAgICAgICBidWxnZSA9IGVudGl0eS52ZXJ0aWNlc1tpXS5idWxnZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQgPSBpICsgMSA8IGVudGl0eS52ZXJ0aWNlcy5sZW5ndGggPyBlbnRpdHkudmVydGljZXNbaSArIDFdIDogZ2VvbWV0cnkudmVydGljZXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgYnVsZ2VHZW9tZXRyeSA9IG5ldyBUSFJFRXguQnVsZ2VHZW9tZXRyeShzdGFydFBvaW50LCBlbmRQb2ludCwgYnVsZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2guYXBwbHkoZ2VvbWV0cnkudmVydGljZXMsIGJ1bGdlR2VvbWV0cnkudmVydGljZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0ZXgueCwgdmVydGV4LnksIDApKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVudGl0eS5zaGFwZSkgZ2VvbWV0cnkudmVydGljZXMucHVzaChnZW9tZXRyeS52ZXJ0aWNlc1swXSk7XG5cblxuICAgICAgICAgICAgLy8gc2V0IG1hdGVyaWFsXG4gICAgICAgICAgICBpZihlbnRpdHkubGluZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBsaW5lVHlwZSA9IGRhdGEudGFibGVzLmxpbmVUeXBlLmxpbmVUeXBlc1tlbnRpdHkubGluZVR5cGVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKHsgY29sb3I6IGNvbG9yLCBnYXBTaXplOiA0LCBkYXNoU2l6ZTogNH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGxpbmV3aWR0aDogMSwgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xuXG4gICAgICAgICAgICAvLyAgICAgICAgICAgLy8gVWdseSBoYWNrIHRvIGFkZCBkaWZmdXNlIHRvIHRoaXMuIE1heWJlIGNvcHkgdGhlIHVuaWZvcm1zIG9iamVjdCBzbyB3ZVxuICAgICAgICAgICAgLy8gICAgICAgICAgIC8vIGRvbid0IGFkZCBkaWZmdXNlIHRvIGEgbWF0ZXJpYWwuXG4gICAgICAgICAgICAvLyAgICAgICAgICAgbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMuZGlmZnVzZSA9IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKGNvbG9yKSB9O1xuXG4gICAgICAgICAgICAvLyBcdG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgICAgIC8vIFx0XHR1bmlmb3JtczogbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMsXG4gICAgICAgICAgICAvLyBcdFx0dmVydGV4U2hhZGVyOiBsaW5lVHlwZS5tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICAvLyBcdFx0ZnJhZ21lbnRTaGFkZXI6IGxpbmVUeXBlLm1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICAvLyBcdH0pO1xuICAgICAgICAgICAgLy8gfWVsc2Uge1xuICAgICAgICAgICAgLy8gXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGxpbmV3aWR0aDogMSwgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBkcmF3QXJjKGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlO1xuICAgICAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbnRpdHkuc3RhcnRBbmdsZSB8fCAwO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50aXR5LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBlbnRpdHkuZW5kQW5nbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5BcmNDdXJ2ZShcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIGVudGl0eS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDMyICk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgY29sb3I6IGdldENvbG9yKGVudGl0eSwgZGF0YSkgfSk7XG5cbiAgICAgICAgICAgIHZhciBhcmMgPSBuZXcgVEhSRUUuTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgYXJjLnBvc2l0aW9uLnggPSBlbnRpdHkuY2VudGVyLng7XG4gICAgICAgICAgICBhcmMucG9zaXRpb24ueSA9IGVudGl0eS5jZW50ZXIueTtcbiAgICAgICAgICAgIGFyYy5wb3NpdGlvbi56ID0gZW50aXR5LmNlbnRlci56O1xuXG4gICAgICAgICAgICByZXR1cm4gYXJjO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsLCBtZXNoLCB2ZXJ0cyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gICAgICAgICAgICB2ZXJ0cyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzBdLngsIGVudGl0eS5wb2ludHNbMF0ueSwgZW50aXR5LnBvaW50c1swXS56KSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb2ludHNbMV0ueCwgZW50aXR5LnBvaW50c1sxXS55LCBlbnRpdHkucG9pbnRzWzFdLnopKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoZW50aXR5LnBvaW50c1syXS54LCBlbnRpdHkucG9pbnRzWzJdLnksIGVudGl0eS5wb2ludHNbMl0ueikpO1xuICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzNdLngsIGVudGl0eS5wb2ludHNbM10ueSwgZW50aXR5LnBvaW50c1szXS56KSk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBkaXJlY3Rpb24gdGhlIHBvaW50cyBhcmUgZmFjaW5nIChjbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2UpXG4gICAgICAgICAgICB2YXIgdmVjdG9yMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2ZWN0b3IxLnN1YlZlY3RvcnModmVydHNbMV0sIHZlcnRzWzBdKTtcbiAgICAgICAgICAgIHZlY3RvcjIuc3ViVmVjdG9ycyh2ZXJ0c1syXSwgdmVydHNbMF0pO1xuICAgICAgICAgICAgdmVjdG9yMS5jcm9zcyh2ZWN0b3IyKTtcblxuICAgICAgICAgICAgLy8gSWYgeiA8IDAgdGhlbiB3ZSBtdXN0IGRyYXcgdGhlc2UgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgICAgaWYodmVjdG9yMS56IDwgMCkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDIsIDEsIDApKTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygyLCAzLCAxKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDAsIDEsIDIpKTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygxLCAzLCAyKSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdUZXh0KGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5LCBtYXRlcmlhbCwgdGV4dDtcblxuICAgICAgICAgICAgaWYoIWZvbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignVGV4dCBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgYSBUaHJlZS5qcyBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIhIExvYWQgYSBmb250IG9mIHlvdXIgY2hvaWNlIGFuZCBwYXNzIHRoaXMgaW50byB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2FtcGxlIGZvciB0aGlzIHJlcG9zaXRvcnkgb3IgVGhyZWUuanMgZXhhbXBsZXMgYXQgaHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzLz9xPXRleHQjd2ViZ2xfZ2VvbWV0cnlfdGV4dCBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXh0R2VvbWV0cnkoZW50aXR5LnRleHQsIHsgZm9udDogZm9udCwgaGVpZ2h0OiAwLCBzaXplOiBlbnRpdHkudGV4dEhlaWdodCB8fCAxMiB9KTtcblxuICAgICAgICAgICAgaWYgKGVudGl0eS5yb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB6Um90YXRpb24gPSBlbnRpdHkucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnJvdGF0ZVooelJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcblxuICAgICAgICAgICAgdGV4dCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkuc3RhcnRQb2ludC54O1xuICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnN0YXJ0UG9pbnQueTtcbiAgICAgICAgICAgIHRleHQucG9zaXRpb24ueiA9IGVudGl0eS5zdGFydFBvaW50Lno7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1BvaW50KGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5LCBtYXRlcmlhbCwgcG9pbnQ7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoZW50aXR5LnBvc2l0aW9uLngsIGVudGl0eS5wb3NpdGlvbi55LCBlbnRpdHkucG9zaXRpb24ueikpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBjb3VsZCBiZSBtb3JlIGVmZmljaWVudC4gUG9pbnRDbG91ZCBwZXIgbGF5ZXI/XG5cbiAgICAgICAgICAgIHZhciBudW1Qb2ludHMgPSAxO1xuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bVBvaW50cyozICk7XG4gICAgICAgICAgICBjb2xvcnNbMF0gPSBjb2xvci5yO1xuICAgICAgICAgICAgY29sb3JzWzFdID0gY29sb3IuZztcbiAgICAgICAgICAgIGNvbG9yc1syXSA9IGNvbG9yLmI7XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9ycyA9IGNvbG9ycztcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBzaXplOiAwLjA1LCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG4gICAgICAgICAgICBwb2ludCA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3RGltZW5zaW9uKGVudGl0eSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5LmJsb2NrXTtcblxuICAgICAgICAgICAgaWYgKCFibG9jayB8fCAhYmxvY2suZW50aXRpZXMpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIC8vIGlmKGVudGl0eS5hbmNob3JQb2ludCkge1xuICAgICAgICAgICAgLy8gICAgIGdyb3VwLnBvc2l0aW9uLnggPSBlbnRpdHkuYW5jaG9yUG9pbnQueDtcbiAgICAgICAgICAgIC8vICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LmFuY2hvclBvaW50Lnk7XG4gICAgICAgICAgICAvLyAgICAgZ3JvdXAucG9zaXRpb24ueiA9IGVudGl0eS5hbmNob3JQb2ludC56O1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2suZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRFbnRpdHkgPSBkcmF3RW50aXR5KGJsb2NrLmVudGl0aWVzW2ldLCBkYXRhLCBncm91cCk7XG4gICAgICAgICAgICAgICAgaWYoY2hpbGRFbnRpdHkpIGdyb3VwLmFkZChjaGlsZEVudGl0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdCbG9jayhlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGRhdGEuYmxvY2tzW2VudGl0eS5uYW1lXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFibG9jay5lbnRpdGllcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGVudGl0eS54U2NhbGUpIGdyb3VwLnNjYWxlLnggPSBlbnRpdHkueFNjYWxlO1xuICAgICAgICAgICAgaWYoZW50aXR5LnlTY2FsZSkgZ3JvdXAuc2NhbGUueSA9IGVudGl0eS55U2NhbGU7XG5cbiAgICAgICAgICAgIGlmKGVudGl0eS5yb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJvdGF0aW9uLnogPSBlbnRpdHkucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbnRpdHkucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBncm91cC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgZ3JvdXAucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGdyb3VwLnBvc2l0aW9uLnogPSBlbnRpdHkucG9zaXRpb24uejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2NrLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRW50aXR5ID0gZHJhd0VudGl0eShibG9jay5lbnRpdGllc1tpXSwgZGF0YSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGlmKGNoaWxkRW50aXR5KSBncm91cC5hZGQoY2hpbGRFbnRpdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IDB4MDAwMDAwOyAvL2RlZmF1bHRcbiAgICAgICAgICAgIGlmKGVudGl0eS5jb2xvcikgY29sb3IgPSBlbnRpdHkuY29sb3I7XG4gICAgICAgICAgICBlbHNlIGlmKGRhdGEudGFibGVzICYmIGRhdGEudGFibGVzLmxheWVyICYmIGRhdGEudGFibGVzLmxheWVyLmxheWVyc1tlbnRpdHkubGF5ZXJdKVxuICAgICAgICAgICAgICAgIGNvbG9yID0gZGF0YS50YWJsZXMubGF5ZXIubGF5ZXJzW2VudGl0eS5sYXllcl0uY29sb3I7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihjb2xvciA9PSBudWxsIHx8IGNvbG9yID09PSAweGZmZmZmZikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVMaW5lVHlwZVNoYWRlcnMoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGx0eXBlLCB0eXBlO1xuICAgICAgICAgICAgaWYoIWRhdGEudGFibGVzIHx8ICFkYXRhLnRhYmxlcy5saW5lVHlwZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGx0eXBlcyA9IGRhdGEudGFibGVzLmxpbmVUeXBlLmxpbmVUeXBlcztcblxuICAgICAgICAgICAgZm9yKHR5cGUgaW4gbHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgbHR5cGUgPSBsdHlwZXNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYoIWx0eXBlLnBhdHRlcm4pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGx0eXBlLm1hdGVyaWFsID0gY3JlYXRlRGFzaGVkTGluZVNoYWRlcihsdHlwZS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURhc2hlZExpbmVTaGFkZXIocGF0dGVybikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgZGFzaGVkTGluZVNoYWRlciA9IHt9LFxuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMC4wO1xuXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gTWF0aC5hYnMocGF0dGVybltpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhc2hlZExpbmVTaGFkZXIudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtcblxuICAgICAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyAnY29tbW9uJyBdLFxuICAgICAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyAnZm9nJyBdLFxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAncGF0dGVybic6IHsgdHlwZTogJ2Z2MScsIHZhbHVlOiBwYXR0ZXJuIH0sXG4gICAgICAgICAgICAgICAgICAgICdwYXR0ZXJuTGVuZ3RoJzogeyB0eXBlOiAnZicsIHZhbHVlOiB0b3RhbExlbmd0aCB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZGFzaGVkTGluZVNoYWRlci52ZXJ0ZXhTaGFkZXIgPSBbXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7JyxcblxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7JyxcblxuICAgICAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnIF0sXG5cbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3ZlcnRleCcgXSxcblxuICAgICAgICAgICAgICAgICd2TGluZURpc3RhbmNlID0gbGluZURpc3RhbmNlOycsXG5cbiAgICAgICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOycsXG5cbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIGRhc2hlZExpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBbXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBkaWZmdXNlOycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgcGF0dGVyblsnICsgcGF0dGVybi5sZW5ndGggKyAnXTsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHBhdHRlcm5MZW5ndGg7JyxcblxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7JyxcblxuICAgICAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSxcbiAgICAgICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19wYXJzX2ZyYWdtZW50JyBdLFxuXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IHBvcyA9IG1vZCh2TGluZURpc3RhbmNlLCBwYXR0ZXJuTGVuZ3RoKTsnLFxuXG4gICAgICAgICAgICAgICAgJ2ZvciAoIGludCBpID0gMDsgaSA8ICcgKyBwYXR0ZXJuLmxlbmd0aCArICc7IGkrKyApIHsnLFxuICAgICAgICAgICAgICAgICdwb3MgPSBwb3MgLSBhYnMocGF0dGVybltpXSk7JyxcbiAgICAgICAgICAgICAgICAnaWYoIHBvcyA8IDAuMCApIHsnLFxuICAgICAgICAgICAgICAgICdpZiggcGF0dGVybltpXSA+IDAuMCApIHsnLFxuICAgICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKTsnLFxuICAgICAgICAgICAgICAgICdicmVhazsnLFxuICAgICAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICAgICAnZGlzY2FyZDsnLFxuICAgICAgICAgICAgICAgICd9JyxcblxuICAgICAgICAgICAgICAgICd9JyxcblxuICAgICAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0sXG4gICAgICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfZnJhZ21lbnQnIF0sXG5cbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXNoZWRMaW5lU2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZEV4dGVudHMoc2NlbmUpIHsgXG4gICAgICAgICAgICBmb3IodmFyIGNoaWxkIG9mIHNjZW5lLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblgsIG1heFgsIG1pblksIG1heFk7XG4gICAgICAgICAgICAgICAgaWYoY2hpbGQucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKGNoaWxkLnBvc2l0aW9uLngsIG1pblgpO1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oY2hpbGQucG9zaXRpb24ueSwgbWluWSk7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi54LCBtYXhYKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGNoaWxkLnBvc2l0aW9uLnksIG1heFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgbWluOiB7IHg6IG1pblgsIHk6IG1pblkgfSwgbWF4OiB7IHg6IG1heFgsIHk6IG1heFkgfX07XG4gICAgICAgIH1cblxuICAgIH19KVxuXG4vKipcbiAqIFZpZXdlciBjbGFzcyBmb3IgYSBkeGYgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0aGUgZHhmIG9iamVjdCBnZW5lcmF0ZWQgYnkgZHhmLXBhcnNlclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudCB0byB3aGljaCB3ZSBhdHRhY2ggdGhlIHJlbmRlcmluZyBjYW52YXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHdpZHRoIG9mIHRoZSByZW5kZXJpbmcgY2FudmFzIGluIHBpeGVsc1xuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIGhlaWdodCBvZiB0aGUgcmVuZGVyaW5nIGNhbnZhcyBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0gYSBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIgXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZpZXdlcihkYXRhLCBwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIGZvbnQpIHtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgRFhGTG9hZGVyKCk7XG5cbiAgICAvLyBDcmVhdGUgVEhSRUUgbWVzaGVzXG4gICAgdmFyIGVudGl0aWVzID0gbG9hZGVyLmxvYWRFbnRpdGllcyhkYXRhLCBmb250KS5lbnRpdGllcztcblxuICAgIHZhciBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG4gICAgLy8gQ3JlYXRlIHNjZW5lIGZyb20gZHhmIG9iamVjdCAoZGF0YSlcbiAgICB2YXIgaSwgb2JqLCBtaW5feCwgbWluX3ksIG1pbl96LCBtYXhfeCwgbWF4X3ksIG1heF96O1xuICAgIHZhciBkaW1zID0ge1xuICAgICAgICBtaW46IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZX0sXG4gICAgICAgIG1heDogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlfVxuICAgIH07XG4gICAgZm9yKGkgPSAwOyBpIDwgZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JqID0gZW50aXRpZXNbaV07XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gbmV3IFRIUkVFLkJveDMoKS5zZXRGcm9tT2JqZWN0KG9iaik7XG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueCAmJiAoKGRpbXMubWluLnggPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueCA+IGJib3gubWluLngpKSkgZGltcy5taW4ueCA9IGJib3gubWluLng7XG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueSAmJiAoKGRpbXMubWluLnkgPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueSA+IGJib3gubWluLnkpKSkgZGltcy5taW4ueSA9IGJib3gubWluLnk7XG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueiAmJiAoKGRpbXMubWluLnogPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueiA+IGJib3gubWluLnopKSkgZGltcy5taW4ueiA9IGJib3gubWluLno7XG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueCAmJiAoKGRpbXMubWF4LnggPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueCA8IGJib3gubWF4LngpKSkgZGltcy5tYXgueCA9IGJib3gubWF4Lng7XG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueSAmJiAoKGRpbXMubWF4LnkgPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueSA8IGJib3gubWF4LnkpKSkgZGltcy5tYXgueSA9IGJib3gubWF4Lnk7XG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueiAmJiAoKGRpbXMubWF4LnogPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueiA8IGJib3gubWF4LnopKSkgZGltcy5tYXgueiA9IGJib3gubWF4Lno7XG4gICAgICAgICAgICBzY2VuZS5hZGQob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBudWxsO1xuICAgIH1cblxuICAgIHdpZHRoID0gd2lkdGggfHwgcGFyZW50LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHBhcmVudC5pbm5lckhlaWdodDtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblxuICAgIHZhciB1cHBlclJpZ2h0Q29ybmVyID0geyB4OiBkaW1zLm1heC54LCB5OiBkaW1zLm1heC55IH07XG4gICAgdmFyIGxvd2VyTGVmdENvcm5lciA9IHsgeDogZGltcy5taW4ueCwgeTogZGltcy5taW4ueSB9O1xuXG4gICAgLy8gRmlndXJlIG91dCB0aGUgY3VycmVudCB2aWV3cG9ydCBleHRlbnRzXG4gICAgdmFyIHZwX3dpZHRoID0gdXBwZXJSaWdodENvcm5lci54IC0gbG93ZXJMZWZ0Q29ybmVyLng7XG4gICAgdmFyIHZwX2hlaWdodCA9IHVwcGVyUmlnaHRDb3JuZXIueSAtIGxvd2VyTGVmdENvcm5lci55O1xuICAgIHZhciBjZW50ZXIgPSBjZW50ZXIgfHwge1xuICAgICAgICB4OiB2cF93aWR0aCAvIDIgKyBsb3dlckxlZnRDb3JuZXIueCxcbiAgICAgICAgeTogdnBfaGVpZ2h0IC8gMiArIGxvd2VyTGVmdENvcm5lci55XG4gICAgfTtcblxuICAgIC8vIEZpdCBhbGwgb2JqZWN0cyBpbnRvIGN1cnJlbnQgVGhyZWVEWEYgdmlld2VyXG4gICAgdmFyIGV4dGVudHNBc3BlY3RSYXRpbyA9IE1hdGguYWJzKHZwX3dpZHRoIC8gdnBfaGVpZ2h0KTtcbiAgICBpZiAoYXNwZWN0UmF0aW8gPiBleHRlbnRzQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgdnBfd2lkdGggPSB2cF9oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2cF9oZWlnaHQgPSB2cF93aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdmlld1BvcnQgPSB7XG4gICAgICAgIGJvdHRvbTogLXZwX2hlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IC12cF93aWR0aCAvIDIsXG4gICAgICAgIHRvcDogdnBfaGVpZ2h0IC8gMixcbiAgICAgICAgcmlnaHQ6IHZwX3dpZHRoIC8gMixcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEodmlld1BvcnQubGVmdCwgdmlld1BvcnQucmlnaHQsIHZpZXdQb3J0LnRvcCwgdmlld1BvcnQuYm90dG9tLCAxLCAxOSk7XG4gICAgY2FtZXJhLnBvc2l0aW9uLnogPSAxMDtcbiAgICBjYW1lcmEucG9zaXRpb24ueCA9IHZpZXdQb3J0LmNlbnRlci54O1xuICAgIGNhbWVyYS5wb3NpdGlvbi55ID0gdmlld1BvcnQuY2VudGVyLnk7XG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICBwYXJlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAvL1RPRE86IE5lZWQgdG8gbWFrZSB0aGlzIGFuIG9wdGlvbiBzb21laG93IHNvIG90aGVycyBjYW4gcm9sbCB0aGVpciBvd24gY29udHJvbHMuXG4gICAgdmFyIGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCBwYXJlbnQpO1xuICAgIGNvbnRyb2xzLnRhcmdldC54ID0gY2FtZXJhLnBvc2l0aW9uLng7XG4gICAgY29udHJvbHMudGFyZ2V0LnkgPSBjYW1lcmEucG9zaXRpb24ueTtcbiAgICBjb250cm9scy50YXJnZXQueiA9IDA7XG4gICAgY29udHJvbHMuem9vbVNwZWVkID0gMztcblxuICAgIC8vVW5jb21tZW50IHRoaXMgdG8gZGlzYWJsZSByb3RhdGlvbiAoZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIHdpdGggMkQgZHJhd2luZ3MpLlxuICAgIC8vY29udHJvbHMuZW5hYmxlUm90YXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkgeyByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSkgfTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICBjb250cm9scy51cGRhdGUoKTtcblxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQud2lkdGg7XG4gICAgICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBoc2NhbGUgPSB3aWR0aCAvIG9yaWdpbmFsV2lkdGg7XG4gICAgICAgIHZhciB2c2NhbGUgPSBoZWlnaHQgLyBvcmlnaW5hbEhlaWdodDtcblxuXG4gICAgICAgIGNhbWVyYS50b3AgPSAodnNjYWxlICogY2FtZXJhLnRvcCk7XG4gICAgICAgIGNhbWVyYS5ib3R0b20gPSAodnNjYWxlICogY2FtZXJhLmJvdHRvbSk7XG4gICAgICAgIGNhbWVyYS5sZWZ0ID0gKGhzY2FsZSAqIGNhbWVyYS5sZWZ0KTtcbiAgICAgICAgY2FtZXJhLnJpZ2h0ID0gKGhzY2FsZSAqIGNhbWVyYS5yaWdodCk7XG5cbi8vICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9O1xufVxuXG4vLyBTaG93L0hpZGUgaGVscGVycyBmcm9tIGh0dHBzOi8vcGxhaW5qcy5jb20vamF2YXNjcmlwdC9lZmZlY3RzL2hpZGUtb3Itc2hvdy1hbi1lbGVtZW50LTQyL1xuLy8gZ2V0IHRoZSBkZWZhdWx0IGRpc3BsYXkgc3R5bGUgb2YgYW4gZWxlbWVudFxuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkodGFnKSB7XG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgMCk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAwKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAwKTtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICAgIHZhciBkb2MgPSAoaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudCkuZG9jdW1lbnQ7XG5cbiAgICAvLyBJRSBzdXBwb3J0XG4gICAgZG9jLndyaXRlKCk7XG4gICAgZG9jLmNsb3NlKCk7XG5cbiAgICB2YXIgdGVzdEVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRlc3RFbCk7XG4gICAgdmFyIGRpc3BsYXkgPSAod2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKHRlc3RFbCwgbnVsbCkgOiB0ZXN0RWwuY3VycmVudFN0eWxlKS5kaXNwbGF5XG4gICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICByZXR1cm4gZGlzcGxheTtcbn1cblxuLy8gYWN0dWFsIHNob3cvaGlkZSBmdW5jdGlvbiB1c2VkIGJ5IHNob3coKSBhbmQgaGlkZSgpIGJlbG93XG5mdW5jdGlvbiBzaG93SGlkZShlbCwgc2hvdykge1xuICAgIHZhciB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vbGRkaXNwbGF5JyksXG4gICAgZGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXksXG4gICAgY29tcHV0ZWREaXNwbGF5ID0gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkgOiBlbC5jdXJyZW50U3R5bGUpLmRpc3BsYXk7XG5cbiAgICBpZiAoc2hvdykge1xuICAgICAgICBpZiAoIXZhbHVlICYmIGRpc3BsYXkgPT09ICdub25lJykgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJycgJiYgKGNvbXB1dGVkRGlzcGxheSA9PT0gJ25vbmUnKSkgdmFsdWUgPSB2YWx1ZSB8fCBkZWZhdWx0RGlzcGxheShlbC5ub2RlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgJiYgZGlzcGxheSAhPT0gJ25vbmUnIHx8ICEoY29tcHV0ZWREaXNwbGF5ID09ICdub25lJykpXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb2xkZGlzcGxheScsIChjb21wdXRlZERpc3BsYXkgPT0gJ25vbmUnKSA/IGRpc3BsYXkgOiBjb21wdXRlZERpc3BsYXkpO1xuICAgIH1cbiAgICBpZiAoIXNob3cgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnIHx8IGVsLnN0eWxlLmRpc3BsYXkgPT09ICcnKVxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlIHx8ICcnIDogJ25vbmUnO1xufVxuXG4vLyBoZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBzaG93KGVsKSB7IHNob3dIaWRlKGVsLCB0cnVlKTsgfVxuZnVuY3Rpb24gaGlkZShlbCkgeyBzaG93SGlkZShlbCk7IH1cblxuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")}])}));